
<!DOCTYPE html>
<html>
<title>ATR</title>
<style>
@font-face {
    font-family: 'Atari';
    src: url(data:application/font-woff;charset=utf-8;base64,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) format('woff');
    font-weight: normal;
    font-style: normal;
}

body {
	background-color:#F8F8F8;
	font-family:"Open Sans","Helvetica Neue",Helvetica;
	padding: 20px;
    display: flex;
    flex-direction: column;
}
canvas {
    border:none;
    padding: 0px;
    margin:0px;
    transform-origin: 0px 2px;
}

nav {
    border: solid 1px #CCC;
    background: #CCF;
}
ul {
    list-style-type: none;
    border:none;
    margin: 0px;
    padding: 0px;
}
li {
    font-size: x-small;
}
li:hover {
    background-color: yellow;
    filter: brightness(200%);
}
li .recovered {
    filter: brightness(75%);
}
li .isdir {
    filter: brightness(125%);
}
h1, h2, h3, h4, h5, h6 {
	font-weight: 300;
}
h2 {
	font-size: 30px;
}
#gl {
	border: solid 1px #C00;
}
canvas {
  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
  image-rendering: -webkit-optimize-contrast; /* Safari                        */
  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
  image-rendering: pixelated;                 /* Awesome future-browsers       */
  image-rendering: crisp-edges;
  -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
}

td {
	border: solid 8px #F8F8F8;
	padding: 16px;
	margin: 16px;
	background: #23A;
	color: #FFF;
	font-weight: 500;
}
.sw {
	background: #A32;
}
.hw {
	background: #3A2;
}

.over {
  border: 2px dashed #F00;
}

.info {
    min-height: 32px;
    padding: 8px;
    border-bottom: 1px solid #CCC;
    font-size: small;
}
.infof {
    min-height: 32px;
    padding: 8px;
    border-bottom: 1px solid #CCC;
    font-size: small;
    overflow: hidden;
}

.close-icon
{
  display:block;
  box-sizing:border-box;
  width:12px;
  height:12px;
  border-width:2px;
  border-style: solid;
  border-color:gray;
  border-radius:100%;
  background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%,  white 56%,transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%,  white 56%,transparent 56%, transparent 100%);
  background-color:gray;
  transition: all 0.3s ease;
  margin: 4px;
  float:right;
}

.close-icon:hover {
    border-color:red;
    background-color:red;
}
.radio {
    user-select: none;
    cursor: pointer;
    font-size: small;
    height:16px;
    margin-left: 12px;
    margin-right: 12px;
    margin-top:4px;
}
.radio:last-child  {
    margin-right: 0px;
}
.radio span {
    border: 1px solid #CCC;
    padding-left: 12px;
    padding-right: 12px;
    vertical-align: top;
}
.hilite {
    background: #CCF;
}
.exts {
    font-weight: 300;
    padding: 4px;
    margin: 4px;
    font-size: small;
    width:600px;
}
.exts b {
    display: inline-block;
    margin-right: 16px;
    width : 140px;
    text-align:right;
}
.open {
    display: inline-block;
    font-size: large;
    cursor: pointer;
    width: 200px;
    border: solid 1px #CCC;
    font-weight: 300;
    margin: 20px;
    color: #AAA;
}
.open:hover {
    color: #888;
    border: solid 1px #888;
}
.open:active {
    color: #FFF;
    border: solid 1px #FFF;
}
.showcode {
    cursor: pointer;
    font-size: x-small;
    height:16px;
    padding: 2px 4px;
    margin-left: 12px;
    margin-right: 12px;
    margin-top:4px;
    border: solid 1px #CCC;
}
.showcode:hover {
    color: #F00;
    border: solid 1px #F00;
}

.palette {
    margin-left: 8px;
    display: inline-block;
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
    display: none;
    position: absolute;
    top:16px;
    background: #CCC;
    min-width: 288px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5);
    z-index: 100;
    margin: 0px;
    padding: 0px;
}

.dropdown:hover .dropdown-content {
  display: block;
}

.acolor {
    display: inline-block;
    min-width: 16px;
    min-height: 16px;
    border: solid 1px #CCC;
    vertical-align: bottom;
}
.acolor:hover {
    border: solid 1px #FFF;
}

.atari {
    font-family: 'Atari';
    font-size:16px;
    line-height:16px;
    background: #153382;
    color: #B5D3FF;
}

#atari_text {
    padding: 4px;
}

pre {
    padding: 8px;
    font-size: 10px;
    line-height: 10px;
}

pre data {
    font-family: 'Atari';
    font-size:8px;
    font-weight: normal;
    background: #153382;
    color: #B5D3FF;
}

.floater {
    position: fixed;
    z-index: 10;
    cursor: pointer;
    user-select: none;
    line-height: 16px;
    letter-spacing: 0px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5);
}

.floater span:hover {
    filter: brightness(200%);
}

.floater span:active {
    background: #B5D3FF;
    color: #153382;
}

.disassembly {
    left: 24px;
    top: 384px;
    width: 492px;
    max-height: 384px;
    overflow: scroll;
    background: #EEE;
}

.draggable {
    width: 100%;
    padding: 4px 8px;
    background: #CCF;
    border: solid 1px #CCC;
    font-size: small;
    font-weight: bold;
}

.tools {
    width: 20px;
    height: 84px;
    left: 0px;
    top: 320px;
    text-align:center;
}

.dimmed {
    filter: brightness(75%);
}

.keyboard {
    display: none;
    left: 24px;
    top: 320px;
    height: 256px;
    width: 256px;
        z-index: 11;
}

.keyboard_invert {
    font-family:"Open Sans","Helvetica Neue",Helvetica;
    text-align: center;
    vertical-align: center;
    color:#000;
    font-size: x-small;
    background: #F8F8F8;
}
.keyboard_invert:hover{
    background: #CCF;
}


</style>
<script>
var _ajax = function(m,u,c,d) {
	var x = new XMLHttpRequest;
	x.onreadystatechange=function(){x.readyState^4||c(this)};
	x.open(m,u);
	if (d) {
		x.setRequestHeader('Content-Type', 'application/json');
		d = JSON.stringify(d);
	}
	x.send(d);
};

var _q = function(q) {
	return document.querySelector(q)
};

var _h = function(q,html) {
    var e = _q(q);
    if (!e) {
        console.log("_h can't find " + q);
        return null;
    }
    return e.innerHTML = html;
};

var _txt = function(q) {
	return _q(q).innerText;
};

function stop()
{
	event.preventDefault();
	event.stopPropagation();
}

function get(url,cb,d)
{
	_ajax(d ? "post":"get",url,function(r) {
		var o = JSON.parse(r.responseText);
		cb(JSON.parse(r.responseText));
	},d);
}

function save_bytes(name, data)
{
    var blob = new Blob([data], {type: "application/data"});
    var link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = name;
    link.click();
};

var _hex = "0123456789ABCDEF";
function hex(i,len)
{
	var s = '';
	if (!len)
		len = 2;
	while(len--)
		s += _hex[(i >> (len*4)) & 0xF];
	return s;
}

function escapestr(c)
{
	switch (c) {
		case "<": return "&lt;"
		case ">": return "&gt;"
	}
	return c;
}

function esc(s)
{
	var n = '';
	for (var i = 0; i < s.length; i++)
		n+= escapestr(s.charAt(i));
	return n;
}

function hex_line(addr,data,i,len,awidth)
{
	var s = [hex(addr,awidth || 6) + "   "];
	var p = '';
    var left = addr & 15;
    var right = (16-((addr + len) & 15)) & 15;
    if (left) {
        p += `<span style='background:#CCC'>${' '.repeat(left-1)} </span>`;
        s.push('   '.repeat(left));
    }
	while (len--) {
		var j = data[i];
        p += String.fromCharCode(j + 0xE000);
		s.push(hex(data[i++],2) + " ");
	}
    if (right) {
        p += `<span style='background:#CCC'>${' '.repeat(right-1)} </span>`;
        s.push('   '.repeat(right));
    }
	return s.join('') + "  <data>" + p + "</data>";
}

function hex_dump(a,i,len,awidth)
{
	var hex = [];
	for (var j = 0; j < len; j += 16)
		hex.push(hex_line(j,a,i+j,Math.min(16,len-j),awidth));
	return hex.join("\n");
}

//===================================================================================================
//===================================================================================================

var _fcanvas;
function draw(ctx,s,x,y,fcanvas)
{
    fcanvas = fcanvas || _fcanvas;
    for (var i = 0; i < s.length; i++) {
        var n = s.charCodeAt(i);
        ctx.drawImage(fcanvas,n*8,0,8,8,x*8,y*8,8,8);
        x++;
    }
}

// generate a canvas containing atari font
function get_font(src,palette,one_bit)
{
    // map atascii to a line of font bits
    // https://www.atariarchives.org/mapping/appendix10.php
    function font_bits(c,y)
    {
        var invert = c & 0x80 ? 0xFF : 0x00;
        c = c & 0x7F;
        if (c >= 32 && c < 96)
            c -= 32;
        else if (c < 32)
            c += 64;
        return src[c*8 + y] ^ invert;
    }

    var canvas = document.createElement('canvas');
    canvas.width = 256*8;
    canvas.height = 8;
    var ctx = canvas.getContext('2d');

    var pix = ctx.getImageData(0,0,256*8,8);
    var d = pix.data;
    var f = 0;
    var i = 0;
    var ap = (p) => {
        p = atari_palette_rgb[palette[p]];
        d[i+0] = (p >> 16) & 0xFF;
        d[i+1] = (p >> 8) & 0xFF;
        d[i+2] = p & 0xFF;
        d[i+3] = 0xFF;
        i += 4;
    }
    if (!palette) {
        palette = [128+20,128+30];
        one_bit = true;
    }
    var bg = atari_palette_rgb[128+20];
    for (var y = 0; y < 8; y++) {
    	for (var c = 0; c < 256; c++)
    	{
    		var b = font_bits(c,y);
            if (palette) {
                if (one_bit) {
                    for (var x = 0; x < 8; x++) {
                        ap((b >> 7)&1);
                        b <<= 1;
                    }
                } else {
                    for (var x = 0; x < 4; x++) {
                        ap((b >> 6) & 3);
                        ap((b >> 6) & 3);
                        b <<= 2;
                    }
                }
            } else {
                /*
        		for (var x = 0; x < 8; x++) {
        			if (b & 0x80) {
              			d[i+0] = 128;
              			d[i+1] = 162;
              			d[i+2] = 255;
              		} else {
              			d[i+0] = (bg >> 16) & 0xFF;
              			d[i+1] = (bg >> 8) & 0xFF;
              			d[i+2] = (bg >> 0) & 0xFF;
              		}
              		d[i+3] = 0xFF;
              		i += 4;
              		b <<= 1;
        		}
                */
            }
    	}
    }
    ctx.putImageData(pix,0,0);
    return canvas;
}

//===================================================================================================
//===================================================================================================

class Octree
{
    constructor(bits)
    {
        this.leaves = 0;
        this.count = 0;
        this.leaf_level = bits || 4;
    }

    insert(node,color,level)
    {
        var level;
        if (!node) {
            node = {
                level:level,
                n:0,
                red:0,
                green:0,
                blue:0,
            }
            if (level < this.leaf_level)
                node.child = [];
            else
                this.leaves++;
        }
        node.n++;
        node.red +=   (color >> 16) & 0xFF;
        node.green += (color >> 8) & 0xFF;
        node.blue +=  color & 0xFF;
        if (node.child)
        {
            var k = this.key(color,level);
            node.child[k] = this.insert(node.child[k],color,level+1);
        }
        return node;
    }

    key(color,level)
    {
        var k = 0;
        var m = 0x80 >> level;
        if ((color >> 16) & m)  k |= 0x04;
        if ((color >> 8) & m)   k |= 0x02;
        if (color & m)          k |= 0x01;
        return k
    }

    color(node)
    {
        var r = node.red/node.n | 0;
        var g = node.green/node.n | 0;
        var b = node.blue/node.n | 0;
        return {n:node.n,color:((r << 16) | (g << 8) | b)};
    }

    add(color)
    {
        this.root = this.insert(this.root,color,0);
        this.count++;
    }

    scan(node,level,list) {
        if (node.level == level)
        {
            list.push(node);
            return;
        }
        if (node.child)
            node.child.forEach(c => this.scan(c,level,list));
    }

    finalize(count)
    {
        var pal;
        var level = 0;
        do {
            pal = [];
            this.scan(this.root,level++,pal);   // scan into levels until we get enough colors
        } while (pal.length < count);
        console.log(pal);
        pal.sort((a,b) => b.n - a.n);
        if (pal.length >= count)
            pal.length = count;
        return pal.map(node => this.color(node));
    }
}

function octree(pix,count,gray)
{
    var d = pix.data;
    var q = new Octree();
    for (var i = 0; i < pix.width*pix.height*4; i += 4) {
        var r = d[i];
        var g = d[i+1];
        var b = d[i+2];
        if (gray)
            r = g = b = (r*0.29 + g*0.59 + b*0.12) | 0;
        q.add((r << 16) | (g << 8) | b,0);
    }

    var pal = q.finalize(count);
    return pal.map(c => rgb2atari((c.color >> 16) & 0xFF,(c.color >> 8) & 0xFF,c.color & 0xFF));
}

//===================================================================================================
//===================================================================================================
//  Kmeans for palettes

function median_cut(pix,centroid_count)
{
    var sample_count = pix.width*pix.height;
    var d = pix.data;
    var index = new Uint32Array(sample_count);
    for (var i = 0; i < sample_count; i++)
        index[i] = i*4;
    var slices = [index];

    function cut(s)
    {
        var rgb = [];
        for (var c = 0; c < 3; c++)
            rgb.push({c:c,min:255,max:0,d:new Uint32Array(256)});
        for (var i = 0; i < s.length; i++) {
            for (var c = 0; c < 3; c++) {
                var v = d[s[i]+c];
                rgb[c].d[v]++;
                rgb[c].min = Math.min(v,rgb[c].min);
                rgb[c].max = Math.max(v,rgb[c].max);
            }
        }
        rgb.sort((a,b) => (b.max-b.min) - (a.max-a.min));
        var split = rgb[0];
        var c = split.c;
        var cut = (split.max+split.min)>>1;
        console.log("Splitting " + ["red","green","blue"][c] + " at " + cut);
        console.log(rgb);

        var left = [];
        var right = [];
        for (var i = 0; i < s.length; i++) {
            if (d[s[i]+c] < cut)
                left.push(s[i]);
            else
                right.push(s[i]);
        }
        return [left,right];
    }

    while (slices.length < centroid_count) {
        slices.sort((a,b) => b.length-a.length);
        var split = cut(slices.shift());
        slices = slices.concat(split);
    }
    console.log(slices);
    var pal = [];
    slices.forEach(s => {
        var r = 0;
        var g = 0;
        var b = 0;
        s.forEach(i => {
            r += d[i];
            g += d[i+1];
            b += d[i+2];
        });
        pal.push(rgb2atari(r/s.length,g/s.length,b/s.length));
    });
    return pal;
}

//===================================================================================================
//===================================================================================================
//  Kmeans for palettes

function kmeans(pix,centroid_count,gray)
{
    console.log("kmeans " + centroid_count + (gray ? "(grayscale)" : ""));
    var sample_count = pix.width*pix.height;
    var samples = [];
    for (var i = 0; i < sample_count; i++)
        samples.push(rgb2yiq(pix.data[i*4+0],pix.data[i*4+1],pix.data[i*4+2]));

    // kmeans++ centroid init
    _lfsr = 0xACE1;
    var rands = () => samples[lfsr() % sample_count];
    var centroids = [{color:rands(),avg:{y:0,i:0,q:0},err:0,count:0}];
    while (centroids.length < centroid_count) {
        var maxe = 0;
        var new_centroid;
        for (var i = 0; i < 100; i++) {
            var s = rands();
            centroids.forEach(c => {
                var e = yiq_distance(s,c.color);
                if (e > maxe) {
                    maxe = e;
                    new_centroid = s;
                }
            });
        }
        centroids.push({color:new_centroid,avg:{y:0,i:0,q:0},err:0,count:0});
    }

    // match samples to centroids
    var last = 0;
    for (var pass = 0; pass < 16; pass++) {

        // match all the samples
        var total_err = 0;
        for (var i = 0; i < sample_count; i++) {
            var mine = 0x7FFFFFF;
            var index = -1;
            var color = samples[i];
            for (var j = 0; j < centroid_count; j++) {
                var e = yiq_distance(color,centroids[j].color);
                if (e < mine) {
                    mine = e;
                    index = j;
                }
            }
            var c = centroids[index];
            c.avg.y += color.y;
            c.avg.i += color.i;
            c.avg.q += color.q;
            c.count++;
            c.err += mine;     // accumulate error
            total_err += mine;
        }

        // recalculate centroid color
        var errs = [];
        for (var i = 0; i < centroid_count; i++) {
            var c = centroids[i];
            if (gray)
                c.avg.i = c.avg.q = 0;
            if (c.count)
                c.color = {y:c.avg.y/c.count, i:c.avg.i/c.count, q:c.avg.q/c.count};
            errs.push({index:i,err:c.err});
        }

        errs.sort((a,b) => b.err - a.err);
        console.log(errs);
        console.log(centroids);

        // split centroids if required
        for (var i = 0; i < centroid_count; i++) {
            if (centroids[i].count == 0) {                              // centroid is not being used
                var c0 = centroids[errs[0].index].color;
                var c1 = centroids[errs[1].index].color;                // make new centroid at average of two biggest errors
                centroids[i].color = {y:(c0.y+c1.y)/2, i:(c0.i+c1.i)/2, q:(c0.q+c1.q)/2};
            }
            // reset centroids
            centroids[i].count = centroids[i].err = 0;
            centroids[i].avg = {y:0,i:0,q:0};
        }

        console.log("pass: " + pass + ":" + total_err);
        if (last && total_err >= last)
            break;
        last = total_err;
    }

    var pal = [];
    for (var i = 0; i < centroid_count; i++) {
        var c = centroids[i].color;
        pal.push(yiq2atari(c.y,c.i,c.q));
    }
    console.log(pal);
    return pal;
}

// 888 rgb to atari
function to_atari(rgb)
{
    var mine = 0x7FFFFFF;
    var mini = -1;
    for (var i = 0; i < 256; i++) {
        var a = atari_palette_rgb[i];
        var r = ((rgb >> 16) & 0xFF) - ((a >> 16) & 0xFF);
        var g = ((rgb >> 8) & 0xFF) - ((a >> 8) & 0xFF);
        var b = (rgb & 0xFF) - (a & 0xFF);
        var e = r*r + g*g + b*b;
        if (e < mine) {
            mine = e;
            mini = i;
        }
    }
    return mini;
}
//===================================================================================================
//===================================================================================================
// Images

var atari_palette_rgb = [
    0x00000000,0x000F0F0F,0x001B1B1B,0x00272727,0x00333333,0x00414141,0x004F4F4F,0x005E5E5E,
    0x00686868,0x00787878,0x00898989,0x009A9A9A,0x00ABABAB,0x00BFBFBF,0x00D3D3D3,0x00EAEAEA,
    0x00001600,0x000F2100,0x001A2D00,0x00273900,0x00334500,0x00405300,0x004F6100,0x005D7000,
    0x00687A00,0x00778A17,0x00899B29,0x009AAC3B,0x00ABBD4C,0x00BED160,0x00D2E574,0x00E9FC8B,
    0x001C0000,0x00271300,0x00331F00,0x003F2B00,0x004B3700,0x00594500,0x00675300,0x00756100,
    0x00806C12,0x008F7C22,0x00A18D34,0x00B29E45,0x00C3AF56,0x00D6C36A,0x00EAD77E,0x00FFEE96,
    0x002F0000,0x003A0000,0x00460F00,0x00521C00,0x005E2800,0x006C3600,0x007A4416,0x00885224,
    0x00925D2F,0x00A26D3F,0x00B37E50,0x00C48F62,0x00D6A073,0x00E9B487,0x00FDC89B,0x00FFDFB2,
    0x00390000,0x00440000,0x0050000A,0x005C0F17,0x00681B23,0x00752931,0x0084373F,0x0092464E,
    0x009C5058,0x00AC6068,0x00BD7179,0x00CE838A,0x00DF949C,0x00F2A7AF,0x00FFBBC3,0x00FFD2DA,
    0x00370020,0x0043002C,0x004E0037,0x005A0044,0x00661350,0x0074215D,0x0082306C,0x00903E7A,
    0x009B4984,0x00AA5994,0x00BC6AA5,0x00CD7BB6,0x00DE8CC7,0x00F1A0DB,0x00FFB4EF,0x00FFCBFF,
    0x002B0047,0x00360052,0x0042005E,0x004E006A,0x005A1276,0x00672083,0x00762F92,0x00843DA0,
    0x008E48AA,0x009E58BA,0x00AF69CB,0x00C07ADC,0x00D18CED,0x00E59FFF,0x00F9B3FF,0x00FFCAFF,
    0x0016005F,0x0021006A,0x002D0076,0x00390C82,0x0045198D,0x0053279B,0x006135A9,0x006F44B7,
    0x007A4EC2,0x008A5ED1,0x009B6FE2,0x00AC81F3,0x00BD92FF,0x00D0A5FF,0x00E4B9FF,0x00FBD0FF,
    0x00000063,0x0000006F,0x00140C7A,0x00201886,0x002C2592,0x003A329F,0x004841AE,0x00574FBC,
    0x00615AC6,0x00716AD6,0x00827BE7,0x00948CF8,0x00A59DFF,0x00B8B1FF,0x00CCC5FF,0x00E3DCFF,
    0x00000054,0x00000F5F,0x00001B6A,0x00002776,0x00153382,0x00234190,0x0031509E,0x00405EAC,
    0x004A68B6,0x005A78C6,0x006B89D7,0x007D9BE8,0x008EACF9,0x00A1BFFF,0x00B5D3FF,0x00CCEAFF,
    0x00001332,0x00001E3E,0x00002A49,0x00003655,0x00004261,0x0012506F,0x00205E7D,0x002F6D8B,
    0x00397796,0x004987A6,0x005B98B7,0x006CA9C8,0x007DBAD9,0x0091CEEC,0x00A5E2FF,0x00BCF9FF,
    0x00001F00,0x00002A12,0x0000351E,0x0000422A,0x00004E36,0x000B5B44,0x00196A53,0x00287861,
    0x0033826B,0x0043927B,0x0054A38C,0x0065B49E,0x0077C6AF,0x008AD9C2,0x009EEDD6,0x00B5FFED,
    0x00002400,0x00003000,0x00003B00,0x00004700,0x0000530A,0x00106118,0x001E6F27,0x002D7E35,
    0x00378840,0x00479850,0x0059A961,0x006ABA72,0x007BCB84,0x008FDE97,0x00A3F2AB,0x00BAFFC2,
    0x00002300,0x00002F00,0x00003A00,0x00004600,0x00115200,0x001F6000,0x002E6E00,0x003C7C12,
    0x0047871C,0x0057972D,0x0068A83E,0x0079B94F,0x008ACA61,0x009EDD74,0x00B2F189,0x00C9FFA0,
    0x00001B00,0x00002700,0x000F3200,0x001C3E00,0x00284A00,0x00365800,0x00446600,0x00527500,
    0x005D7F00,0x006D8F19,0x007EA02B,0x008FB13D,0x00A0C24E,0x00B4D662,0x00C8EA76,0x00DFFF8D,
    0x00110E00,0x001D1A00,0x00292500,0x00353100,0x00413D00,0x004F4B00,0x005D5A00,0x006B6800,
    0x0076720B,0x0085821B,0x0097932D,0x00A8A43E,0x00B9B650,0x00CCC963,0x00E0DD77,0x00F7F48F,
];

function rgb2yiq(r,g,b)
{
    return {
        y:r * 0.299 + g * 0.587 + b * 0.114,
        i:r * 0.596 - g * 0.275 - b * 0.321,
        q:r * 0.212 - g * 0.523 + b * 0.311
    }
}

function rgb2atari(r,g,b)
{
    var yiq = rgb2yiq(r,g,b);
    var angle = Math.atan2(yiq.i,yiq.q);
    var saturation = yiq.i*yiq.i + yiq.q*yiq.q;
    var offset = (180-26.8)*Math.PI/180.0;
    var scale = 360/26.8;
    var cr = (offset - angle)*scale/(2*Math.PI) | 0;
    cr %= 15;
    if (saturation < 1)
        cr = 0;
    else
        cr++;
    return (cr << 4) | (yiq.y/16|0);
}

function atari2yiq(a)
{
    var cr = a >> 4;
    var i = 0;
    var q = 0;
    if (cr) {
        var color_diff = 2*Math.PI*26.8/360;
        var angle = Math.PI * 303/180 + (cr-1)*color_diff;
        i = Math.cos(angle)*63;
        q = Math.sin(angle)*63;
    }
    return {y:(a & 0xF)*16, i:i, q:q};
}

function yiq2atari(y,i,q)
{
    var angle = Math.atan2(i,q);
    var saturation = i*i + q*q;
    var offset = (180-26.8)*Math.PI/180.0 - angle;
    if (offset < 0)
        offset += 2*Math.PI;
    var scale = 360/26.8;
    var cr = offset*scale/(2*Math.PI);
    cr = (cr + 0.5) | 0;
    if (saturation < 256)
        cr = 0;
    else
        cr = (cr+1) & 0xF;
    cr = (cr << 4) | ((y/16)|0);
    console.log("y:" + y + " i:" + i + " q:" + q + " -> " + hex(cr) + " sat:" + saturation);
    return cr;
}

function yiq_distance(a,b)
{
    var dy = a.y-b.y;
    var di = a.i-b.i;
    var dq = a.q-b.q;
    return dy*dy + di*di + dq*dq;
}

// 
var _lfsr = 0xACE1;
function lfsr()
{
    _lfsr ^= _lfsr >> 7;
    _lfsr ^= _lfsr << 9;
    _lfsr ^= _lfsr >> 13;
    return _lfsr;
}

// mode 0 = Atkinson Dither
// mode 1 = Floyd Steinberg
// mode 2 = noise
// mode 3 = ordered
// mode 4 = No diffusion

var _ordered8x8 = new Uint8Array([
     0, 32,  8, 40,  2, 34, 10, 42,
    48, 16, 56, 24, 50, 18, 58, 26,
    12, 44,  4, 36, 14, 46,  6, 38,
    60, 28, 52, 20, 62, 30, 54, 22,
     3, 35, 11, 43,  1, 33,  9, 41,
    51, 19, 59, 27, 49, 17, 57, 25,
    15, 47,  7, 39, 13, 45,  5, 37,
    63, 31, 55, 23, 61, 29, 53, 21
]);

var _ordered16x16 = new Uint8Array([
      0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255,
    128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127,
     32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223,
    160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95,
      8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247,
    136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119,
     40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215,
    168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87,
      2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253,
    130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125,
     34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221,
    162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93,
     10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245,
    138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117,
     42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213,
    170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85
]);

function dither_image(pix,pal,mode)
{
    mode = mode || 0;
    var d = pix.data;
    var buf = new Uint8Array(3);
    var errs = new Int16Array(3);
    var dst = new Uint8Array(pix.width*pix.height);
    var distance = _radios["distance"].value;
    var dscale = pal.length == 2 ? 0.75 : 0.25;

    function get_index(src,p)
    {
        var mind = -1;
        var merr = 0xFFFFFF;

        if (distance == 0)  // RGB distnance measure
        {
            var r = src[p+0];
            var g = src[p+1];
            var b = src[p+2];
            var e;
            for (var i = 0; i < pal.length; i++) {
                var err = 0;
                var c = atari_palette_rgb[pal[i]];
                e = r - ((c >> 16) & 0xFF);
                err += e*e;
                e = g - ((c >> 8) & 0xFF);
                err += e*e;
                e = b - (c & 0xFF);
                err += e*e;
                if (err < merr) {
                    merr = err;
                    mind = i;
                }
            }
        } else {
            var pyiq= rgb2yiq(src[p+0],src[p+1],src[p+2]);  // yiq + y only
            var e;
            for (var i = 0; i < pal.length; i++) {
                var err = 0;
                var yiq = atari2yiq(pal[i]);
                e = yiq.y - pyiq.y;
                err += e*e*2;
                if (distance == 1) {        // include chroma
                    e = yiq.i - pyiq.i;
                    err += e*e;
                    e = yiq.q - pyiq.q;
                    err += e*e;
                }
                if (err < merr) {
                    merr = err;
                    mind = i;
                }
            }
        }

        var c = atari_palette_rgb[pal[mind]];
        errs[0] = (src[p+0] - ((c >> 16) & 0xFF));   // save error in RGB
        errs[1] = (src[p+1] - ((c >> 8) & 0xFF));
        errs[2] = (src[p+2] - ((c >> 0) & 0xFF));
        return pal[mind];    // closest index
    }

    function pin(n) {
        if (n < 0) return 0;
        if (n > 255) return 255;
        return n;
    }

    function rnd()
    {
        return ((lfsr() & 0xFF)-128)*dscale;
    }

    function noisy(i)
    {
        buf[0] = pin(d[i+0] + rnd());
        buf[1] = pin(d[i+1] + rnd());
        buf[2] = pin(d[i+2] + rnd());
    }

    function ordered(i,x,y)
    {
        var n = ((x & 0xF) << 4) | (y & 0xF);
        n = (_ordered16x16[n]-128)*dscale;
        buf[0] = pin(d[i+0] + n);
        buf[1] = pin(d[i+1] + n);
        buf[2] = pin(d[i+2] + n);
    }

    function add_err(x,y,scale) {
        scale = scale || 1/6;   // Atkinson
        if (x < 0 || x >= pix.width || y < 0 || y >= pix.height)
            return;
        var i = (x + y*pix.width)*4;
        d[i+0] = pin(d[i+0]+errs[0]*scale);
        d[i+1] = pin(d[i+1]+errs[1]*scale);
        d[i+2] = pin(d[i+2]+errs[2]*scale);
    }

    var i = 0;
    var row = 0;
    for (var y = 0; y < pix.height; y++) {
        for (var x = 0; x < pix.width; x++) {
            switch (mode) {
                case 0:
                    dst[i++] = get_index(d,row+x*4);    // Atkinson
                    add_err(x+1,y+0);
                    add_err(x+2,y+0);
                    add_err(x-1,y+1);
                    add_err(x+0,y+1);
                    add_err(x+1,y+1);
                    add_err(x+0,y+2);
                    break;

                case 1:
                    dst[i++] = get_index(d,row+x*4);    // Floyd Steinberg
                    add_err(x+1,y+0,7/16);
                    add_err(x-1,y+1,3/16);
                    add_err(x+0,y+1,5/16);
                    add_err(x+1,y+1,1/16);
                    break;

                case 2:
                    noisy(row+x*4);
                    dst[i++] = get_index(buf,0);
                    break;

                case 3: // ordered
                    ordered(row+x*4,x,y);
                    dst[i++] = get_index(buf,0);
                    break;

                case 4: // none
                    dst[i++] = get_index(d,row+x*4);
                    break;
            }
        }
        row += pix.width*4;
    }
    return dst;
}

function pack_img(indexes,pal,ext)
{
    var dst = 0;
    var bpp = 2;
    switch (ext)
    {
        case 'gr8':
            bpp = 1;
            break;
        case 'gr9':
        case 'g10':
            bpp = 4;
            break;
    }
    var ppb = 8/bpp;
    var pal_len = pal ? pal.length : 0;
    var d = new Uint8Array(indexes.length/ppb + pal_len);

    for (var i = 0; i < indexes.length; ) {
        var b = 0;
        for (var j = 0; j < ppb; j++) {
            b <<= bpp;
            if (pal_len)
                b |= pal.indexOf(indexes[i++]);
            else
                b |= indexes[i++];
        }
        d[dst++] = b;
    }
    for (var i = 0; i < pal_len; i++)
        d[dst++] = pal[i];
    return d;
}

function raw_rgb(pix)
{
    var n = pix.width*pix.height;
    var d = new Uint8Array(n*3);
    if (1) {
        var pal = [];
        for (var i = 0; i < 256; i++)
            pal.push(i);
        var indexed = dither_image(pix,pal,1); 
        for (var i = 0; i < n; i++) {
            var c = atari_palette_rgb[indexed[i]];  // 
            d[i*3+0] = (c >> 16) & 0xFF;
            d[i*3+1] = (c >> 8) & 0xFF;
            d[i*3+2] = c & 0xFF;
        }
    } else {
        for (var i = 0; i < n; i++) {
            d[i*3+0] = pix.data[i*4+0];
            d[i*3+1] = pix.data[i*4+1];
            d[i*3+2] = pix.data[i*4+2];
        }
    }
    return d;
}

// raw rgb
function show_rgb(canvas,f)
{
    canvas.width = f.data.length == (320*192*3) ? 320 : 160;
    canvas.height = 192;
    var ctx = canvas.getContext('2d');
    var pix = ctx.getImageData(0,0,canvas.width,canvas.height);
    var d = pix.data;
    var s = f.data;
    var n = canvas.width*canvas.height;
    var p = {};
    for (var i = 0; i < n; i++)
    {
        var r = d[i*4+0] = s[i*3+0];
        var g = d[i*4+1] = s[i*3+1];
        var b = d[i*4+2] = s[i*3+2];
        d[i*4+3] = 0xFF;
        p[(r << 16) | (g << 8) | b] = 1;
    }
    var pal = [];
    Object.keys(p).forEach(c => pal.push(rgb2atari((c >> 16) | 0xFF,(c >> 8) & 0xFF, c & 0xFF)));
    ctx.putImageData(pix,0,0);
    return {pal:pal,aspect:[320/canvas.width*2,192/canvas.height*2]};
}

var _mono_cr = 0;
function convert_image(canvas,f,pal,reload)
{
    //if (f.name.indexOf(".rgb") != -1)
    //    return show_rgb(canvas,f);

    var dither = _radios["dither"].value;
    var scheme = _radios["scheme"].value;

    var width = 320;
    var height = 192;

    var img = f.img;
    var src_width = img.width;
    var src_height = img.height;
    var dst_width,dst_height;
    var ratio = img.width/img.height;
    if (ratio > width/height)
    {
        dst_width = width;  
        dst_height = width/ratio;    // wide
    } else {
        dst_height = height;
        dst_width = height*ratio;    // tall
    }

    // 80,160 or 320 wide
    var pal_size = 0;
    switch (f.ext) {
        case "gr7":
            width /= 2;
            if (src_width == 160 && src_height == 192) {
                // already native size
            } else {
                dst_width /= 2;
            }
            pal_size = 4;
            break;
        case "gr8":
            pal_size = 2;
            break;
        case "gr9":
            pal = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
        case "g10":
            width /= 4;
            if (src_width == 80 && src_height == 192) {
                // already native size
            } else {
                dst_width /= 4;
            }
            pal_size = f.ext == "g10" ? 9 : 0;
            break;
    }

    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.fillRect(0,0,width,height);
    ctx.drawImage(f.img,0,0,img.width,src_height,(width-dst_width)/2,(height-dst_height)/2,dst_width,dst_height);

    var pix = ctx.getImageData(0,0,width,height);
    //f.rgb = raw_rgb(pix);

    var mono = -1;
    if (reload && pal_size) {
        function monochrome(c) {
            for (var i = 0; i < pal_size; i++)  // make a grey palette, will apply chroma later
                pal[i] = (i*15/(pal_size-1)) | (_mono_cr << 4);
            mono = c;
        }
        switch (scheme) {
            case 0:
                monochrome(0x00);   // grey
                break;
            case 1:     // red-green
                switch (pal_size) {
                    case 2: pal = [0x45,0xE9]; break;
                    case 4: pal = [0x71,0x45,0xE9,0x0D]; break; // Technicolor 100
                    case 9: pal = [0x71,0x45,0xE9,0x47,0xE7,0x07,0x49,0xE5,0x0D]; break; // Technicolor 100
                        break;
                }
                break;
            case 2:      // random
                for (var i = 0; i < pal.length; i++)
                    pal[i] = lfsr() & 0xFF;
                break;

            case 3: // kmeans
                pal = kmeans(pix,pal_size);
                break;

            case 4: // octree
                pal = octree(pix,pal_size);
                break;

            case 5:
                pal = median_cut(pix,pal_size);
                break;
        }
    }

    // dither to atari palette
    var indexed = dither_image(pix,pal,dither); 

    // apply mono color if any
    if (mono != -1) {
        for (var i = 0; i < pal.length; i++)
            pal[i] |= mono;
        for (var i = 0; i < indexed.length; i++)
            indexed[i] |= mono;
    }

    // pack into the appropriate format
    f.packed_img = pack_img(indexed, pal_size ? pal : null,f.ext);

    // turn it back into RGB to display
    var rgb = Uint32Array.from(indexed).map(i => atari_palette_rgb[i]);
    rgb2canvas(canvas,rgb,width,height,1);
    return {pal:pal,aspect:[320/canvas.width*2,192/canvas.height*2]};
}

// atari index color to canvas
// may stretch horizontally to maintain aspect ratio
function rgb2canvas(canvas,atari,width,height,aspect,brightness)
{
    brightness = brightness || 1;
    canvas.width = width*aspect;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    var pix = ctx.getImageData(0,0,width*aspect,height);
    var d = pix.data;
    var src = 0;
    var i = 0;
    var pin = (p) => Math.min(0xFF,(p & 0xFF)*brightness);
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var c = atari[src++];
            for (var j = 0; j < aspect; j++) {
                d[i+0] = pin(c >> 16);
                d[i+1] = pin(c >> 8);
                d[i+2] = pin(c);
                d[i+3] = 0xFF;
                i += 4;
            }
        }
    }
    ctx.putImageData(pix,0,0);
}

// convert a koala into a mic
function koala(src)
{
    var dst = new Uint8Array(7684);
    var dst_len = 7680;
    var i = src[4] + 1;
    var j = 0;
    var end = src.length;
    var type = src[7];

    if (type == 0) {
        while (i < end)
            dst[j++] = src[i++];  // no compression
    } else {
        while (i < end)
        {
            var b = src[i++];
            var len = b & 0x7F;
            if (len == 0) {
                len = src[i++] << 8;
                len |= src[i++];
            }
            b = (b & 0x80) ? -1 : src[i++];

            do {
                dst[j] = b < 0 ? src[i++] : b;
                if (j == (dst_len-1))
                    break;
                if (type == 2)
                    j++;
                else {
                    j += 80;
                    if (j >= dst_len)
                        j -= (j < dst_len + 40) ? dst_len - 40 : dst_len + 39;
                }
            } while (--len > 0);
        }
    }

    dst[7680] = src[17];
    dst[7681] = src[13];
    dst[7682] = src[14];
    dst[7683] = src[15];
    return dst;
}

// unpack from Piotr Fusik and Adrian Matoga

function unpack_rip(data,data_len,unpacked_data,unpacked_len)
{
    function create_fano_tree(src,offset,n,tree)
    {
        var i;
        var pos = 0;
        var positions = new Int32Array(16);
        for (i = 0; i < 16; i++)
            tree.count[i] = 0;
        for (i = 0; i < n; i++) {
            var bits = src[(i >> 1) + offset];
            bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
            tree.count[bits]++;
        }
        for (i = 0; i < 16; i++) {
            positions[i] = pos;
            pos += tree.count[i];
        }
        for (i = 0; i < n; i++) {
            var bits = src[(i >> 1) + offset];
            bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
            tree.values[positions[bits]++] = i & 0xFF;
        }
    }

    function get_bit(s)
    {
        var bits = s.bits;
        if (bits == 0x80) {
            if (s.offset >= s.length)
                return -1;
            bits = s.bytes[s.offset++] * 2 + 1;
        }
        else
            bits <<= 1;
        s.bits = bits & 0xFF;
        return bits >> 8;
    }

    function get_code(s,tree)
    {
        var p = tree.count[0];
        var i = 0;
        var bits;
        for (bits = 1; bits < 16; bits++) {
            var n = tree.count[bits];
            var bit = get_bit(s);
            if (bit == -1)
                return -1;
            i = i * 2 + bit;
            if (i < n)
                return tree.values[p + i];
            p += n;
            i -= n;
        }
        return -1;
    }

    var length_tree = {count:new Int32Array(16),values:new Uint8Array(256)};
    var distance_tree= {count:new Int32Array(16),values:new Uint8Array(256)};
    var literal_tree= {count:new Int32Array(16),values:new Uint8Array(256)};
    var stream = { bits:0x80, bytes:data, length:data_len, offset:16 + 288 };
    var unpacked_offset;

    /* "PCK" header (16 bytes) */
    if (data_len < 304 || data[0] != 80 || data[1] != 67 || data[2] != 75)  // PCK
        return 0;

    /* 288 bytes Shannon-Fano bit lengths */
    create_fano_tree(data,16, 64, length_tree);
    create_fano_tree(data,16 + 32, 256, distance_tree);
    create_fano_tree(data,16 + 32 + 128, 256, literal_tree);

    /* LZ77 */
    for (unpacked_offset = 0; unpacked_offset < unpacked_len; ) {
        switch (get_bit(stream)) {
        case -1:
            console.log(`rip truncation: got ${unpacked_offset} of ${unpacked_len}`);
            return 0;
        case 0:
            unpacked_data[unpacked_offset++] = get_code(stream,literal_tree);
            break;
        case 1:
            {
                var distance = get_code(stream, distance_tree) + 2;
                var len;
                if (distance > unpacked_offset)
                    return 0;
                len = get_code(stream, length_tree) + 2;
                do {
                    unpacked_data[unpacked_offset] = unpacked_data[unpacked_offset - distance];
                    unpacked_offset++;
                } while (--len > 0);
                break;
            }
        }
    }
    return 1;
}

function rip(d)
{
    var mode = d[7];
    var hdr_len = d[11] + (d[12] << 8);
    var height = d[15];
    var txt_len = d[17];
    var pal_len = d[20 + txt_len];
    var dst;
    var txt = '';

    for (var i = 0; i < txt_len; i++)
        txt += String.fromCharCode(d[24+i]);
    console.log(`rip mode:${mode}, rowbytes:${d[13]}, height:${d[15]} txt:${txt}`);

    if (d[9] == 0) {
        dst = d.slice(hdr_len,d.length);
    } else if (d[9] == 1) {
        var n = d[13];
        if (mode == 0x30)
            n += 4;  // 8 byte palette every 2nd line at end of image(s)
        n *= height;
        dst = new Uint8Array(n);
        var src = d.slice(hdr_len,d.length);
        if (!unpack_rip(src,src.length,dst,n))
            console.log("bad unpack_rip?");
    } else
        return null;

    // Copy palette
    var pal = new Uint8Array(pal_len);
    for (var i = 0; i < pal_len; i++)
        pal[i] = d[24 + txt_len + i];

    // separate mutlirip palette
    var multihip_pal = null;
    if (mode == 0x30) {
        var n = d[13]*height;
        multihip_pal = dst.slice(n,dst.length);
        dst = dst.slice(0,n);
    }
    // have the unpacked frame
    return {
        pal:pal,
        multihip_pal:multihip_pal,
        data:dst,
        ext:"rip_hip",
        mode:mode
    }
}

var _palette = [0,5,10,15];
var _reload_palette = 1;
var _palettable = ["gr7","gr8","g10","mic","mcp","inp","cin","pic","scr"];
function is_palettable(ext)
{
    return _palettable.indexOf(ext) != -1;
}

function render_image(canvas,f)
{
    var def_palette = [0,5,10,15];
    switch (f.ext) {
        case "gr8": def_palette = [0,15]; break;
        case "g10": def_palette = [0,2,4,6,8,10,12,14,15]; break;
    }
    var pal0 = _reload_palette ? def_palette.slice() : _palette.slice();
    var pal1 = _reload_palette ? def_palette.slice() : _palette.slice();
    var hip =  [0,0,2,4,6,8,10,12,14, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0];
    var multihip_pal = null;

    // We are rendering an image
  //  if (f.img || (f.name.indexOf(".rgb") != -1)) {
    if (f.img) {
        var r = convert_image(canvas,f,pal0,_reload_palette);
        if (_reload_palette) {
            _palette = r.pal.slice();
            redraw_palette();
        }
        return r.aspect;
    }

    var data = f.data;
    var ext = f.ext;
    var height = 192;
    var width = 160;
    var offset = 40;
    var offset2 = 40;
    var gr = 7;
    var src = 0;

    // Turn PIC into MIC
    if (ext == "pic") {
        data = koala(data);
        ext = "mic";
    }

    // Turn RIP into something
    if (ext == "rip")
    {
        var r = rip(data);
        data = r.data;
        ext = r.ext;
        hip = r.pal;

        switch (r.mode) {
            case 14: ext = "rip_mode_14"; break;
            case 16: ext = "rip_mode_16"; break;
            case 30:
                ext = "inp";
                for (var i = 0; i < 4; i++)
                    pal0[i] = pal1[i] = hip[4 + ((i-1)&3)];
                break;
            case 48:
                ext = "rip_multirip";
                multihip_pal = r.multihip_pal;
                break;
        }
    }

    function set_pal(p,offset,len)
    {
        if (_reload_palette) {
            pal0.length = len;
            pal1.length = len;
            for (var i = 0; i < len; i++)
                pal0[i] = pal1[i] = p[offset++];
            _palette = pal0.slice();
            redraw_palette();
        }
    }

    function avg(p0,p1)
    {
        return ((atari_palette_rgb[p0] & 0x00FEFEFE) + (atari_palette_rgb[p1] & 0x00FEFEFE)) >> 1;
    }

    // Atari Graphics Works?
    if (ext == "scr" && data.length == 16000)
    {
        data = data.slice(0,7684);
        ext = "gr7";
    }

    switch (data.length)
    {
        case 3844:
        case 7684:
        case 9604:
        case 16004: // Interpainter
            set_pal(data,data.length-4,4);
            break;

        case 7682:
            set_pal(data,data.length-2,2);
            break;

        case 7689:
            set_pal(data,data.length-9,9);
            break;
    }

    switch (ext) {
        case "mic":
        case "gr7":
            height = 96;
            if (data.length >= 7680)
                height = 192;
            break;

        case "gr8":
            width = 320;
            gr = 8;
            if (data.length == 7680)
                set_pal([0,0xF],0,2);
            break;

        case "gr9":
            width = 80;
            gr = 9;
            break;

        case "g10":
            width = 80;
            gr = 10;
            break;

        case "ilc":
        case "pzm":
            width = 80;
            offset = 40*192;
            gr = 33;
            break;

        case "plm":
        case "apc":
            width = 80;
            height = 96;
            gr = 32;
            break;

        case "mcp":
            height = data.length == 16008 ? 200:100;
            for (var i = 0; i < 4; i++) {
                pal0[i] = data[height*80+((i-1)&3)];
                pal1[i] = data[height*80+4+((i-1)&3)];
            }
            offset = height*40;
            gr = 39;
            break;

        case "inp":
            height = 200;
            offset = height*40;
            gr = 37;
            break;

        // switch between Graphics 11 and Graphics 15
        // https://en.wikipedia-on-ipfs.org/wiki/Atari_8-bit_family_software-driven_graphics_modes.html
        case "cin":
            offset = 80*height/2;
            gr = 34;
            break;

        case "raw":
            src += 4;       // skip header 'XLPB'
            for (var i = 0; i < 4; i++) {
                pal0[i] = data[0x3C04 + ((i-1)&3)];
                pal1[i] = data[0x3C08 + ((i-1)&3)];
            }
            height = 192;
            gr = 37;
            break;

        case "ist":
            height = 200;
            src = 16;
            offset = 0x2000;
            gr = 35;
            break;

        case "hip":
            // 10 and 9 greyscale
            gr = 36;
            var hdr = le16(data,0); // FFFF
            if (hdr == 0xFFFF && data.length != 16009) {    // Has header: Frames have explicit length
                var len0 = le16(data,4)-le16(data,2)+1;
                var len1 = le16(data,4+len0+6)-le16(data,2+len0+6)+1;
                src += 6;
                offset = len0 + 6;
                height = len0/40;
            } else {
                height = data.length/80 | 0;
                src = height*40;
                offset = -height*40;
                var p = height*80;
                if ((p + 9) == data.length) {   // has a palette?
                    for (var i = 0; i < 9; i++)
                        hip[i] = data[p++];
                }
            }
            break;

        case "tip":
            width = data[5];
            height = data[6];
            var frame_len = data[7] | (data[8] << 8);
            // 3 frames: gr9 luma, gr10 luma, gr11 chroma
            src += 9;                   // gr9 luma
            offset = frame_len;         // gr10 luma
            offset2 = frame_len*2;      // chroma
            gr = 38;
            break;

        case "rip_hip":
        case "rip_multirip":
            height = data.length/80;
            offset = height*40;
            gr = 36;
            break;

        case "rip_mode_14":
            height = 192;
            for (var i = 0; i < 4; i++) {
                pal0[i] = pal1[i] = hip[4+(i == 0 ? 4:i-1)] & 0xFE;
                set_pal(pal0,0,4);
            }
            gr = 7;
            break;

        case "rip_mode_16":
            for (var i = 0; i < 4; i++) {
                pal0[i] = hip[4 + i]; // TODO: why are they all dark?
                pal1[i] = hip[0 + i] & 0xFE;
            }
            height = data.length/80;
            offset = data.length/2;
            gr = 37;    //
            break;
    }

    var buf = new Uint32Array(width*height);
    var dst = 0;
    var lastp = 0;
    var ap = atari_palette_rgb;
    for (var y = 0; y < height; y++) {
        var pal = (y & 1) ? pal1 : pal0;

        if (gr == 35) { // ist palette
            pal0[0] = pal1[0]= data[0x4000 + y];
            pal0[1] = pal1[1]= data[0x40C8 + y];
            pal0[2] = pal1[2]= data[0x4190 + y];
            pal0[3] = pal1[3]= data[0x4258 + y];
        }

        if (multihip_pal)
        {
            for (var i = 0; i < 16; i++) {
                var gr10_to_reg = [0,1,2,3,4,5,6,7,8,8,8,8,4,5,6,7];
                hip[i] = i == 0 ? 0 : multihip_pal[gr10_to_reg[i] + ((y>>1)<<3) - 1] & 0xFE;
            }
        }

        for (var x = 0; x < width;) {
            var b = data[src];
            switch (gr) {
                case 7:
                    for (var j = 0; j < 4; j++) {
                        var bb = (b >> 6) & 3;
                        buf[dst++] = ap[pal[bb]];
                        b <<= 2;
                    }
                    x += 4;
                    break;

                case 8:
                    for (var j = 0; j < 8; j++) {
                        var bb = (b >> 7) & 1;
                        buf[dst++] = ap[pal[bb]];
                        b <<= 1;
                    }
                    x += 8;
                    break;

                case 9:
                    buf[dst++] = ap[b >> 4];        // 9=16 greys,10=index,11=chroma
                    buf[dst++] = ap[b & 0x0F];
                    x += 2;
                    break;

                case 10:
                    buf[dst++] = ap[pal[b >> 4]];
                    buf[dst++] = ap[pal[b & 0x0F]];
                    x += 2;
                    break;

                case 32:
                    var luma = data[src+offset];
                    buf[dst++] = ap[((luma >> 4) & 0x0F) | (b & 0xF0)];
                    buf[dst++] = ap[(luma & 0xF) | ((b & 0xF) << 4)];
                    x += 2;
                    break;

                case 33:
                    var hue = data[src+offset];
                    buf[dst++] = ap[((b >> 4) & 0x0F) | (hue & 0xF0)];
                    buf[dst++] = ap[(b & 0xF) | ((hue & 0xF) << 4)];
                    x += 2;
                    break;

                case 34: // Champions
                    var hue = data[src+offset];
                    buf[dst++] = ap[pal[b >> 6] | (hue & 0xF0)];
                    buf[dst++] = ap[pal[(b >> 4) & 3] | (hue & 0xF0)];
                    buf[dst++] = ap[pal[(b >> 2) & 3] | ((hue & 0xF) << 4)];
                    buf[dst++] = ap[pal[b & 3] | ((hue & 0xF) << 4)];
                    x += 4;
                    break;

                case 36:  // hip
                    //  00001111
                    //  LL222233
                    var p2 = hip[b >> 4];         // gr10
                    var p3 = hip[b & 0xF];
                    b = data[src+offset];
                    var p0 = b >> 4;                // gr9
                    var p1 = b & 0xF;

                    buf[dst++] = avg(p0,lastp);
                    buf[dst++] = avg(p0,p2);
                    buf[dst++] = avg(p1,p2);
                    buf[dst++] = avg(p1,p3);
                    lastp = p3;
                    x += 4;
                    break;// hip

                case 35: // ist
                case 37: // rip_mode_16/inp
                    var b2 = data[src+offset];
                    var pal_0 = (y & 1) ? pal1 : pal0;
                    var pal_1 = (y & 1) ? pal0 : pal1;
                    for (var j = 0; j < 4; j++) {
                        var p0 = pal_1[(b2 >> 6) & 3];
                        var p1 = pal_0[(b >> 6) & 3];
                        buf[dst++] = avg(p0,p1);
                        b <<= 2;
                        b2 <<= 2;
                    }
                    x += 4;
                    break;

                case 39: // mcp
                    var b2 = data[src+offset];
                    for (var j = 0; j < 4; j++) {
                        var p0 = pal0[(b >> 6) & 3];
                        var p1 = pal1[(b2 >> 6) & 3];
                        buf[dst++] = avg(p0,p1);
                        b <<= 2;
                        b2 <<= 2;
                    }
                    x += 4;
                    break;

                case 38: // tip!
                    var luma = data[src];
                    var luma10 = data[src+offset];
                    var chroma = data[src+offset2];          // chroma

                    var l0 = ((luma >> 4) + lastp) >> 1;
                    var l1 = ((luma >> 4) + hip[luma10 >> 4]) >> 1;
                    var l2 = ((luma & 0xF) + hip[luma10 >> 4]) >> 1;
                    lastp = hip[luma10 & 0xF];
                    var l3 = ((luma & 0xF) + lastp) >> 1;

                    var c0 = chroma & 0xF0;
                    var c1 = (chroma << 4) & 0xF0;

                    buf[dst++] = ap[c0|l0];
                    buf[dst++] = ap[c0|l1];
                    buf[dst++] = ap[c1|l2];        // 9=16 greys,10=index,11=chroma
                    buf[dst++] = ap[c1|l3];
                    x += 4;
                    break;            
            }
            src++;
        }
        if (gr == 32 && offset == 40)
            src += 40;
    }

    var brightness = 1;
    switch (ext) {
        case "rip_mode_16": brightness = 3; break;    // rip_mode_16,raw is dark, boost it please
        case "raw":
        case "mcp":
            brightness = 2;
            break;
    }
    rgb2canvas(canvas,buf,width,height,320/width,brightness);
    return [320/canvas.width*2,192/canvas.height*2];
}

//===================================================================================================
//===================================================================================================
// UI

// make an atari line of text to look like dir

function set_class(el,cname,on)
{
    if (on)
        el.classList.add(cname);
    else
        el.classList.remove(cname);
}

function draw_line(id,txt,recovered,is_dir)
{
    var c = _q(id);
    c.width = txt.length*8;
    c.height = 8;
    var ctx = c.getContext('2d');
    draw(ctx,txt,0,0);
    resize_parent(c,2);
    set_class(c,"recovered",recovered);
    set_class(c,"isdir",is_dir);
}

// Simple radio and check buttons
var _radios = {};
var _checks = {};
function radio_init(name,values,value)
{
    var cur = _radios[name] ? _radios[name].value : 0;
    value = value || cur;
    var s = '';
    for (var i = 0; i < values.length; i++)
        s += `<span onclick="radio_click('${name}',${i})" ${i == value ? "class='hilite'" : ""}>${values[i]}</span>`;
    _radios[name] = {values:values,value:value};
    return s;
}

function radio_click(name,n)
{
    var v = _radios[name];
    if (n != -1 && n != v.value) {
        v.value = n;
        radio_changed(name,n);
    }
}

function radio_changed(name,v)
{
    switch (name) {
        case "layout":
        case "dither":
        case "scheme":
        case "distance":
            refresh();
            break;
    }
}

function check_init(name,dname)
{
    _checks[name] = _checks[name] || 0;
    var cur = _checks[name] ? _checks[name] : 0;
    return `<span onclick="check_click('${name}')" ${cur ? "class='hilite'" : ""}>${dname}</span>`;
}

function check_click(name,n)
{
    _checks[name] ^= 1;
    check_changed(name,_checks[name]);
}

function check_changed(name,v)
{
    switch (name) {
        case "indent":
        case "multicolor":
            refresh();
            break;
    }
}

function resize_parent(e,sx,sy)
{
    sy = sy || sx;
    e.style.transform = `scale(${sx},${sy})`;
    e.parentNode.style.width = e.width*sx + "px";
    e.parentNode.style.height = e.height*sy + "px";
}

// U+200B ZERO-WIDTH SPACE after ':',',''
function atari2ascii(lst,insert_breaks)
{
    var r = [];
    var wbr = insert_breaks ? String.fromCharCode(0x200B) : null;   // ZERO-WIDTH SPACE
    lst.forEach(src => {
        var dst = '';
        for (var i = 0; i < src.length; i++) {
            var c = src.charCodeAt(i);
            switch (c) {
                case 0x7B: // { in ascii, spade in atari
                case 0x7D: // } in ascii, upleft in atari
                case 0x7E: // ~ in ascii, left triangle in atari
                case 0x7F: // right triangle in atari
                    c += 0xE000;
                    break;
                default:
                    if (c < 0x20 || c > 0x7E)   // keep printing chars whole
                        c += 0xE000;
            }
            c = String.fromCharCode(c);
            dst += c;
            if (wbr && (c == ':' || c == ','))
                dst += wbr;
        }
        r.push(dst);
    })
    return r;
}

function ascii2atari(lst)
{
    var d = [];
    lst.forEach(src => {
        for (var i = 0; i < src.length; i++) {
            c = src.charCodeAt(i);
            if (c != 0x200B)
                d.push(c & 0xFF);
        }
        d.push(0x9B);
    });
    return new Uint8Array(d);
}

function editor()
{
    return _q("#atari_text");
}

function get_ataritext()
{
    return ascii2atari(editor().innerText.split("\n"));
}

var _gs = window.getSelection || document.getSelection;
function get_selection()
{
    return _gs().toString();
}

function invert_selection()
{
    keyboard(get_selection(),true);
}

function disassemble_selection()
{
    var txt = get_selection();
    if (!txt || !txt.length)
        return;

    var asm = [];
    for (var i = 0; i < txt.length; i++)
        asm.push(txt.charCodeAt(i)&0xFF);
    var dis = _q(".disassembly");
    draggable(dis,_shown.name + " disassembly");
    _h("#disassembly",xex_dump("asm",asm,0,asm.length));

    var r = _gs().getRangeAt(0).getBoundingClientRect();
    var dx = (dis.width - r.width)/2;
    dis.style.left = ((dx | 0) + r.left) + "px";
    dis.style.top = r.bottom + 4 + "px";
    dis.hidden = false;
    editor().focus();
}

function selection_change()
{
    var el = document.activeElement;
    if (el.id == "atari_text")
    {
        var txt = get_selection();
        var sel = txt && txt.length;
        set_tool("I",sel);  // we have a selection
        set_tool("D",sel);
    }
}

function keyboard(txt,invert)
{
    var e = editor();
    if (!e)
        return;

    if (!txt) {
        e.focus();
        return;
    }

    // same in ATASCII as ASCII
    // will cause unescaping of <>& etc
    function common_chars(s)
    {
        var dst = '';
        for (var i = 0; i < s.length; i++) {
            var c = s.charCodeAt(i);
            if ((c & 0xFF) >= 0x20 && ((c & 0xFF) < 0x7B))
                c &= 0xFF;
            dst += String.fromCharCode(c);
        }
        return dst;
    }

    if (invert) {
        txt = get_selection();
        var s = '';
        for (var i = 0; i < txt.length; i++) {
            var c = txt.charCodeAt(i);
            c = ((c < 0x20) || (c == 0x200B)) ? c : (c ^ 0x80) | 0xE000;
            s += String.fromCharCode(c);
        }
        txt = s;
    }
    txt = common_chars(txt);

    var range = _gs().getRangeAt(0);
    if (invert)
        range.deleteContents();
    else
        range.collapse();

    // insert
    if (txt.indexOf('\n') != -1) {  // need to deal with newlines and insert the as breaks
        var lst = txt.split('\n');
        var n = [];
        for (var i = 0; i < lst.length; i++) {
            n.push(document.createTextNode(lst[i]));
            if (i != lst.length-1)
                n.push(document.createElement("br"));
        }
        var i = n.length;
        while (i--)
            range.insertNode(n[i]);
        range.setEndAfter(n[n.length-1]);
    } else
        range.insertNode(document.createTextNode(txt));
    e.focus();
}

function show_ataritext(f,lst)
{
    render_file(f);
    var layout = _radios["layout"].value;
    var cols = layout < 2 ? 40:80;
    if (layout == 3)
        lst.forEach(s => cols = Math.max(cols,s.length));
    lst = atari2ascii(lst,f.ext == "bas");

    var ta = editor();
    if (layout == 0) {
        ta.style.paddingLeft = '32px';
        cols -= 2;
    }
    else
        ta.style.paddingLeft = '0px';
    if (layout == 3)
        ta.style.fontSize = ta.style.lineHeight = '8px';
    else {
        ta.style.fontSize = ta.style.lineHeight = '16px';
        ta.style.minWidth = ta.style.maxWidth = (cols*16) + "px";
    }
    ta.innerText = lst.join('\n');
}

// old fashioned font
function show_font(f,lst,font,palette)
{
    render_file(f);

    var fcanvas;
    if (font)
        fcanvas = get_font(font,palette);

    var layout = _radios["layout"].value;
    var cols = layout < 2 ? 40:80;
    var margin = layout == 0 ? 2 : 0;
    var wrap = [];

    if (layout == 3) {  // Don't wrap at all
        lst.forEach(line => cols = Math.max(line.length,cols));
        cols += 2*margin;
        wrap = lst;
    } else {
        var wrap = [];
        lst.forEach(s => {
            while (s.length > (cols-margin))
            {
                wrap.push(s.substr(0,(cols-margin)));
                s = s.substr((cols-margin));
            }
            wrap.push(s);
        });
    }

    var c = _q("#show");
    c.width = cols*8;
    c.height = wrap.length*8+16;
    var ctx = c.getContext('2d');
    ctx.webkitImageSmoothingEnabled = false;
    var bg = atari_palette_rgb[palette ? palette[0] : 128+20];
    ctx.fillStyle = '#'+hex(bg,6); // "rgba(17,59,128,1)";
    ctx.fillRect(0, 0, c.width, c.height);
    for (var y = 0; y < wrap.length; y++)
        draw(ctx,wrap[y],margin,y+1,fcanvas);
    resize_parent(c,layout == 3 ? 1:2);
}

var _font = [
    // atari 128 rom font
    // 32..95
    // 0..31
    // 96..128
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x00,
    0x00,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
    0x00,0x66,0xff,0x66,0x66,0xff,0x66,0x00,
    0x18,0x3e,0x60,0x3c,0x06,0x7c,0x18,0x00,
    0x00,0x66,0x6c,0x18,0x30,0x66,0x46,0x00,
    0x1c,0x36,0x1c,0x38,0x6f,0x66,0x3b,0x00,
    0x00,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x0e,0x1c,0x18,0x18,0x1c,0x0e,0x00,
    0x00,0x70,0x38,0x18,0x18,0x38,0x70,0x00,
    0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,
    0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,
    0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,
    0x00,0x06,0x0c,0x18,0x30,0x60,0x40,0x00,
    0x00,0x3c,0x66,0x6e,0x76,0x66,0x3c,0x00,
    0x00,0x18,0x38,0x18,0x18,0x18,0x7e,0x00,
    0x00,0x3c,0x66,0x0c,0x18,0x30,0x7e,0x00,
    0x00,0x7e,0x0c,0x18,0x0c,0x66,0x3c,0x00,
    0x00,0x0c,0x1c,0x3c,0x6c,0x7e,0x0c,0x00,
    0x00,0x7e,0x60,0x7c,0x06,0x66,0x3c,0x00,
    0x00,0x3c,0x60,0x7c,0x66,0x66,0x3c,0x00,
    0x00,0x7e,0x06,0x0c,0x18,0x30,0x30,0x00,
    0x00,0x3c,0x66,0x3c,0x66,0x66,0x3c,0x00,
    0x00,0x3c,0x66,0x3e,0x06,0x0c,0x38,0x00,
    0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x00,
    0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x30,
    0x06,0x0c,0x18,0x30,0x18,0x0c,0x06,0x00,
    0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,
    0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00,
    0x00,0x3c,0x66,0x0c,0x18,0x00,0x18,0x00,
    0x00,0x3c,0x66,0x6e,0x6e,0x60,0x3e,0x00,
    0x00,0x18,0x3c,0x66,0x66,0x7e,0x66,0x00,
    0x00,0x7c,0x66,0x7c,0x66,0x66,0x7c,0x00,
    0x00,0x3c,0x66,0x60,0x60,0x66,0x3c,0x00,
    0x00,0x78,0x6c,0x66,0x66,0x6c,0x78,0x00,
    0x00,0x7e,0x60,0x7c,0x60,0x60,0x7e,0x00,
    0x00,0x7e,0x60,0x7c,0x60,0x60,0x60,0x00,
    0x00,0x3e,0x60,0x60,0x6e,0x66,0x3e,0x00,
    0x00,0x66,0x66,0x7e,0x66,0x66,0x66,0x00,
    0x00,0x7e,0x18,0x18,0x18,0x18,0x7e,0x00,
    0x00,0x06,0x06,0x06,0x06,0x66,0x3c,0x00,
    0x00,0x66,0x6c,0x78,0x78,0x6c,0x66,0x00,
    0x00,0x60,0x60,0x60,0x60,0x60,0x7e,0x00,
    0x00,0x63,0x77,0x7f,0x6b,0x63,0x63,0x00,
    0x00,0x66,0x76,0x7e,0x7e,0x6e,0x66,0x00,
    0x00,0x3c,0x66,0x66,0x66,0x66,0x3c,0x00,
    0x00,0x7c,0x66,0x66,0x7c,0x60,0x60,0x00,
    0x00,0x3c,0x66,0x66,0x66,0x6c,0x36,0x00,
    0x00,0x7c,0x66,0x66,0x7c,0x6c,0x66,0x00,
    0x00,0x3c,0x60,0x3c,0x06,0x06,0x3c,0x00,
    0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x00,
    0x00,0x66,0x66,0x66,0x66,0x66,0x7e,0x00,
    0x00,0x66,0x66,0x66,0x66,0x3c,0x18,0x00,
    0x00,0x63,0x63,0x6b,0x7f,0x77,0x63,0x00,
    0x00,0x66,0x66,0x3c,0x3c,0x66,0x66,0x00,
    0x00,0x66,0x66,0x3c,0x18,0x18,0x18,0x00,
    0x00,0x7e,0x0c,0x18,0x30,0x60,0x7e,0x00,
    0x00,0x1e,0x18,0x18,0x18,0x18,0x1e,0x00,
    0x00,0x40,0x60,0x30,0x18,0x0c,0x06,0x00,
    0x00,0x78,0x18,0x18,0x18,0x18,0x78,0x00,
    0x00,0x08,0x1c,0x36,0x63,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,
    0x00,0x36,0x7f,0x7f,0x3e,0x1c,0x08,0x00,
    0x18,0x18,0x18,0x1f,0x1f,0x18,0x18,0x18,
    0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
    0x18,0x18,0x18,0xf8,0xf8,0x00,0x00,0x00,
    0x18,0x18,0x18,0xf8,0xf8,0x18,0x18,0x18,
    0x00,0x00,0x00,0xf8,0xf8,0x18,0x18,0x18,
    0x03,0x07,0x0e,0x1c,0x38,0x70,0xe0,0xc0,
    0xc0,0xe0,0x70,0x38,0x1c,0x0e,0x07,0x03,
    0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,0xff,
    0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,
    0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff,
    0x0f,0x0f,0x0f,0x0f,0x00,0x00,0x00,0x00,
    0xf0,0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,
    0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
    0x00,0x00,0x00,0x00,0xf0,0xf0,0xf0,0xf0,
    0x00,0x1c,0x1c,0x77,0x77,0x08,0x1c,0x00,
    0x00,0x00,0x00,0x1f,0x1f,0x18,0x18,0x18,
    0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,
    0x18,0x18,0x18,0xff,0xff,0x18,0x18,0x18,
    0x00,0x00,0x3c,0x7e,0x7e,0x7e,0x3c,0x00,
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
    0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
    0x00,0x00,0x00,0xff,0xff,0x18,0x18,0x18,
    0x18,0x18,0x18,0xff,0xff,0x00,0x00,0x00,
    0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
    0x18,0x18,0x18,0x1f,0x1f,0x00,0x00,0x00,
    0x78,0x60,0x78,0x60,0x7e,0x18,0x1e,0x00,
    0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x00,
    0x00,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,
    0x00,0x18,0x30,0x7e,0x30,0x18,0x00,0x00,
    0x00,0x18,0x0c,0x7e,0x0c,0x18,0x00,0x00,
    0x00,0x18,0x3c,0x7e,0x7e,0x3c,0x18,0x00,
    0x00,0x00,0x3c,0x06,0x3e,0x66,0x3e,0x00,
    0x00,0x60,0x60,0x7c,0x66,0x66,0x7c,0x00,
    0x00,0x00,0x3c,0x60,0x60,0x60,0x3c,0x00,
    0x00,0x06,0x06,0x3e,0x66,0x66,0x3e,0x00,
    0x00,0x00,0x3c,0x66,0x7e,0x60,0x3c,0x00,
    0x00,0x0e,0x18,0x3e,0x18,0x18,0x18,0x00,
    0x00,0x00,0x3e,0x66,0x66,0x3e,0x06,0x7c,
    0x00,0x60,0x60,0x7c,0x66,0x66,0x66,0x00,
    0x00,0x18,0x00,0x38,0x18,0x18,0x3c,0x00,
    0x00,0x06,0x00,0x06,0x06,0x06,0x06,0x3c,
    0x00,0x60,0x60,0x6c,0x78,0x6c,0x66,0x00,
    0x00,0x38,0x18,0x18,0x18,0x18,0x3c,0x00,
    0x00,0x00,0x66,0x7f,0x7f,0x6b,0x63,0x00,
    0x00,0x00,0x7c,0x66,0x66,0x66,0x66,0x00,
    0x00,0x00,0x3c,0x66,0x66,0x66,0x3c,0x00,
    0x00,0x00,0x7c,0x66,0x66,0x7c,0x60,0x60,
    0x00,0x00,0x3e,0x66,0x66,0x3e,0x06,0x06,
    0x00,0x00,0x7c,0x66,0x60,0x60,0x60,0x00,
    0x00,0x00,0x3e,0x60,0x3c,0x06,0x7c,0x00,
    0x00,0x18,0x7e,0x18,0x18,0x18,0x0e,0x00,
    0x00,0x00,0x66,0x66,0x66,0x66,0x3e,0x00,
    0x00,0x00,0x66,0x66,0x66,0x3c,0x18,0x00,
    0x00,0x00,0x63,0x6b,0x7f,0x3e,0x36,0x00,
    0x00,0x00,0x66,0x3c,0x18,0x3c,0x66,0x00,
    0x00,0x00,0x66,0x66,0x66,0x3e,0x0c,0x78,
    0x00,0x00,0x7e,0x0c,0x18,0x30,0x7e,0x00,
    0x00,0x18,0x3c,0x7e,0x7e,0x18,0x3c,0x00,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x00,0x7e,0x78,0x7c,0x6e,0x66,0x06,0x00,
    0x08,0x18,0x38,0x78,0x38,0x18,0x08,0x00,
    0x10,0x18,0x1c,0x1e,0x1c,0x18,0x10,0x00,
];

function makefont()
{
	
}

//===================================================================================================
//===================================================================================================
//  Drag and drop

function drop_init(el,onfile,all_done)
{
    function over(b)
    {
        set_class(_q("#toc"),"over",b);
    }

    function handleFiles(files)
    {
        function readAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const fr = new FileReader();
                fr.onerror = reject;
                fr.onload = function(evt) {
                    onfile(file,evt.target.result);
                    resolve(fr.result);
                }
                fr.readAsArrayBuffer(file);
            });
        }

        // Load all the files, callback when done
        Promise.all(Array.prototype.map.call(files,readAsArrayBuffer))
        .then(urls => {
            all_done();
        })
        .catch(error => {
            console.log(error);
        });
    }

    function handleFileSelect(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        over(0);
        handleFiles(evt.dataTransfer.files);

        // check for dragged urls of images
        var items = evt.dataTransfer.items;
        for (var i = 0; i < items.length; i++) {
            if (items[i].kind == 'string' && items[i].type == 'text/uri-list') {
                items[i].getAsString(s => console.log(s));  // cross origin will make this useless
            }
        }
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }
    el.addEventListener('dragover', handleDragOver, false);
    el.addEventListener('drop', handleFileSelect, false);
    el.addEventListener('dragenter', e => over(1), false);
    el.addEventListener('dragleave', e => over(0), false);

    _q("#fe").addEventListener("change", e => handleFiles(_q("#fe").files), false);
}

//===================================================================================================
//===================================================================================================
// http://www.atarimax.com/jindroush.atari.org/afmtbas.html
// Disassemble m65

var _mac65_table1 = [
    "ERROR -", ".IF",     ".ELSE",   ".ENDIF",  ".MACRO",  ".ENDM",   ".TITLE",  "",        
    ".PAGE",   ".WORD",   ".ERROR",  ".BYTE",   ".SBYTE",  ".DBYTE",  ".END",    ".OPT",    
    ".TAB",    ".INCLUDE",".DS",     ".ORG",    ".EQU",    "BRA",     "TRB",     "TSB",     
    ".FLOAT",  ".CBYTE",  ";",       ".LOCAL",  ".SET",    "*=",      "=",       ".=",      
    "JSR",     "JMP",     "DEC",     "INC",     "LDX",     "LDY",     "STX",     "STY",     
    "CPX",     "CPY",     "BIT",     "BRK",     "CLC",     "CLD",     "CLI",     "CLV",     
    "DEX",     "DEY",     "INX",     "INY",     "NOP",     "PHA",     "PHP",     "PLA",     
    "PLP",     "RTI",     "RTS",     "SEC",     "SED",     "SEI",     "TAX",     "TAY",     
    "TSX",     "TXA",     "TXS",     "TYA",     "BCC",     "BCS",     "BEQ",     "BMI",     
    "BNE",     "BPL",     "BVC",     "BVS",     "ORA",     "AND",     "EOR",     "ADC",     
    "STA",     "LDA",     "CMP",     "SBC",     "ASL",     "ROL",     "LSR",     "ROR",     
    "",        "STZ",     "DEA",     "INA",     "PHX",     "PHY",     "PLX",     "PLY",     
];

var _mac65_table2 = [
    null,    null,    null,    null,    null,    "",      "",      "",      
    "",      null,    "",      "%$",    "%",    "*",     null,    null,    
    null,    null,    "+",     "-",     "*",     "/",     "&",     null,    
    "=",     "<=",    ">=",    "<>",    ">",     "<",     "-",     "[",     
    "]",     null,    null,    null,    "!",     "^",     null,    "\\",     
    null,    null,    null,    null,    null,    null,    null,    ".REF",  
    ".DEF",  ".NOT",  ".AND",  ".OR",   "<",     ">",     ",X)",   "),Y",   
    ",Y",    ",X",    ")",     "",      null,    ",",     "#",     "A",     
    "(",     '"',     null,    null,    null,    "NO",    "OBJ",   "ERR",   
    "EJECT", "LIST",  "XREF",  "MLIST", "CLIST", "NUM",   null,    null,    
];

function mac65(a,i,len)
{
    if (le16(a,i) != 0xFEFE)
        return null;
    if (le16(a,i+2) != (len-4))
        return null;
    var end = i + len;
    i += 4;

    var indent = 5;
    var asm = [];
    while (i < len) {
        var line_number = le16(a,i);
        var line_end = i + a[i+2];
        i += 3;

        var s = line_number + ' ';
        var pad = (''+line_number).length + indent;
        var c = a[i++];
        if (c & 0x80) {
            c -= 0x80;  // label
            while (c--)
                s += String.fromCharCode(a[i++]);
            if (i == line_end)
            {
                asm.push(s);
                continue;
            }
            c = a[i++];
        } else if (c == 0 || c == 88) {
            while (i < line_end)
                s += String.fromCharCode(a[i++]);   // raw
            asm.push(s);
            continue;
        } else if (c == 1) {
            indent++;           // IF
        } else if (c == 3) {
            indent--;           // ENDIF
        }

        if (c >= 96)
            return null;
        while (s.length < pad)
            s += ' ';
        if (s[s.length-1] != ' ')
            s += ' ';
        s += _mac65_table1[c] + ' ';   // token

        while (i < line_end) {
            c = a[i++];
            switch (c) {
                case 5: s += '$'+hex(le16(a,i),4); i += 2;      break;
                case 6: s += '$'+hex(a[i++]);                   break;
                case 7: s += le16(a,i); i += 2;                 break;
                case 8: s += a[i++];                            break;
                case 10: s += "'"+String.fromCharCode(a[i++]);  break;
                case 59:
                    s += ' ';
                    while (i < line_end)
                        s += String.fromCharCode(a[i++]);   // comment
                    break;
                default:
                    if (c & 0x80) {
                        c -= 0x80;
                        while (c--)
                            s += String.fromCharCode(a[i++]);
                    } else {
                        var t = _mac65_table2[c];
                        if (!t)
                            return null;
                        s += t;
                        if (c > 64)
                            s += ' ';   // not sure all of all the padding rules
                    }
                    break;
            }
        }
        asm.push(s);
    }
    return asm;
}

//===================================================================================================
//===================================================================================================
// http://www.atarimax.com/jindroush.atari.org/afmtbas.html
// Disassemble atari basic

var _basic_commands = [
    // 56 in classic Basic
	"REM","DATA","INPUT","COLOR","LIST","ENTER","LET","IF","FOR","NEXT","GOTO",
	"GO TO","GOSUB","TRAP","BYE","CONT","COM","CLOSE","CLR","DEG","DIM","END",
	"NEW","OPEN","LOAD","SAVE","STATUS","NOTE","POINT","XIO","ON","POKE","PRINT",
	"RAD","READ","RESTORE","RETURN","RUN","STOP","POP","?","GET","PUT","GRAPHICS",
	"PLOT","POSITION","DOS","DRAWTO","SETCOLOR","LOCATE","SOUND","LPRINT","CSAVE",
	"CLOAD","LET_","ERROR",

    // Turbo Basic
    "DPOKE ","MOVE ","-MOVE ","*F" ,"REPEAT ","UNTIL ","WHILE ","WEND ",
    "ELSE ","ENDIF ","BPUT ","BGET ","FILLTO ","DO ","LOOP ","EXIT ",
    "DIR ","LOCK ","UNLOCK ","RENAME ","DELETE ","PAUSE ","TIME$= ","PROC ",
    "EXEC ","ENDPROC ","FCOLOR ","*L ",
    "------------------------------",
    "RENUM ","DEL ","DUMP ",
    "TRACE ","TEXT ","BLOAD ","BRUN ","GO# ","# ", "*B ","PAINT ",
    "CLS ","DSOUND ","CIRCLE ","%PUT ","%GET "
];

var _basic_operators = [
	"_0","_1","_2","_3","_4","_5","_6","_7","_8","_9","_A","_B","_C","_D",
	"NCONST","SCONST","NOUSE","NOUSE",",","$",":",";","EOL"," GOTO "," GOSUB "," TO ",
	" STEP "," THEN ","#","<=","<>",">=","<",">","=","^","*","+","-","/"," NOT "," OR "," AND ",
	"(",")","=","=","<=","<>",">=","<",">","=","+","-","(","(","(","(","(",",",
	"STR$","CHR$","USR","ASC","VAL","LEN","ADR","ATN","COS","PEEK","SIN","RND","FRE",
	"EXP","LOG","CLOG","SQR","SGN","ABS","INT","PADDLE","STICK","PTRIG","STRIG",

    // Turbo Basic
    "DPEEK","&","!","INSTR","INKEY$"," EXOR ","HEX$","DEC",
    " DIV ","FRAC","TIME$","TIME"," MOD ","EXEC ","RND","RAND",
    "TRUNC","%0","%1","%2","%3","GO# ","UINSTR","ERR","ERL"
];

function ataribasic(a,i,len)
{
    var indenting = _checks['indent'];
	var b = {
		lomem: le16(a,i+0),   // should be zero
		vnt: le16(a,i+2),     // start of variable name table
		vnte: le16(a,i+4),    // end of variable name table
		vvt: le16(a,i+6),     // start of variable values table
		stmtab: le16(a,i+8),  // start of token area
		stmcur: le16(a,i+10), // current line (line 32768)
		starp: le16(a,i+12),  // end of token area, start of stacks

		variable_names:[],
		variable_values:[],
		statements:[]
	}

    function failed(reason)
    {
        reason = reason || "Bytes don't look like Basic";
        console.log(reason);
        console.log(b);
        console.log(listing);
        return null;
    }

	var origin = b.vnt - b.lomem - 14; // file offsets are weird?
    if (origin < 0)
        return failed();
	b.vnt -= origin;
	b.vnte -= origin;
	b.vvt -= origin;
	b.stmtab -= origin;
	b.stmcur -= origin;
	b.starp -= origin;
    if (b.vnt > b.vnte || b.vnte > b.vvt || b.vvt > b.stmtab || b.stmtab > b.stmcur || b.stmcur > b.starp)
        return failed();    // Not a basic file?

	function get_string(data,si,len) {
		var s = '';
		while (len--) {
            var c = String.fromCharCode(data[si++]);
			s += c;
            if (c == '"')
                s += c;
        }
		return s;
	}

	function bcd(data,bi)
	{
		var n = 0;
		var e = data[bi++];
		if (e == 0)
			return 0;
		for (var j = 0; j < 5; j++) {
			var c = data[bi++];
			n *= 10;
			n += c >> 4;
			n *= 10;
			n += c & 0xF;
		}
		e = (e - 68) * 2;

		switch (e) {	// Math.pow was not producing integers
			case -1: return n/10;
			case -2: return n/100;
			case -3: return n/1000;
			case -4: return n/10000;
		}
		return n*Math.pow(10,e);
	}

	var vnt_begin = i + b.vnt;
	var vnt_end = i + b.vnte;
	var n = '';
    var nmap = {};
    var ncount = 0;
	for (var j = vnt_begin; j < vnt_end; j++) {
		n += String.fromCharCode(a[j]&0x7F);
		if (a[j] & 0x80)
		{
			if (n.length && n[n.length-1] == '(')
				n = n.substr(0,n.length-1);	// 
            if (nmap[n])
                console.log(`reapeated variable name '${n}'`);
            nmap[n] = 1;
            ncount++;
			b.variable_names.push(n);
			n = '';
		}
	}

    if (Object.keys(nmap).length == 1)
    {
        console.log("resetting variable names");
        b.variable_names = [];  // name table was set to the same value: reset it
    }

	var vvt_begin = i + b.vvt;	// NOT SURE WHY THESE ARE +1
	var tokens_begin = i + b.stmtab;
    var vid = 0;
	for (var j = vvt_begin; j < tokens_begin; j += 8) {
        var v = {name:b.variable_names[a[j+1]]};

        if (!v.name) {  // someone got rid of all the variable names. make new ones
            var ch = String.fromCharCode(65+(vid % 26));    // 'A'
            var n = Math.floor(vid++/26);
            if (n)
                ch += n+1;                              // A,B,C ... A2,B2...
            switch (a[j]) {
                case 0x80:
                case 0x81:
                    ch += '$';
                    break;
            }
            b.variable_names[a[j+1]] = v.name = ch;     // make up a name if missing
        }

		var p0 = le16(a,j+2);
		var p1 = le16(a,j+4);
		var p2 = le16(a,j+6);
		switch (a[j]) {
			case 0x00:
				v.type = "scalar";
				v.value = bcd(a,j+2);
				break;
			case 0x40:
			case 0x41:
				v.type = "array";
				break;
			case 0x80:
			case 0x81:
				v.type = "string";
				v.value = get_string(a,b.starp+i+p0,p1);
				break;
			default:
				v.type = a[j];
		}
		b.variable_values.push(v);
	}

    //var tokens_end = i+b.stmcur;
    var tokens_end = i+b.starp; // kings cribbage see https://www.atariarchives.org/mapping/memorymap.php STMCUR
    var turbo = false;

	var listing = [];
    var indent = 0;
	for (var j = tokens_begin; j < tokens_end;) {
		var s = {tok:[]};
		s.lineno = le16(a,j);
		var len = a[j+2];

        if (s.lineno == 32768 || len == 0)
            break; // stmcur

		var line = s.lineno + " ";

        if (indent) {
			var cmd = a[j+4];
            // Check if indent needs to decreased *before* the first command:
            //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF     ELSE
            if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41 || cmd == 0x40)
                line = line + " ".repeat(2 * indent - 2);
            else
                line = line + " ".repeat(2 * indent);
        }

		// Parse statements
		var k = 3;
        var op;
		while (k < len) {
			var end = a[j+k];
			var cmd = a[j+k+1];
			k += 2;
            if (cmd >= 56) {
                turbo = true;
                if (cmd >= 101)
                    return failed("Unrecognized command index:" + cmd);    // not basic
            }

			s.tok.push(_basic_commands[cmd]);
			if (cmd != 0x36) {	// slient LET
			    line += _basic_commands[cmd];
                if (line[line.length-1] != ' ')
                    line += ' ';
            }

			if (cmd < 2) {	// REM,DATA
				var txt = '';
				while (k < end) {
                    var c = a[j+k++];
                    if (c == 0x9B)
                        break;
					txt += String.fromCharCode(c);
                }
				s.tok.push(txt);
				line += txt;
				k = end;
			}

            // Check indent:
            //         FOR            REPEAT         WHILE          DO             PROC
            if (cmd == 0x08 || cmd == 0x3C || cmd == 0x3E || cmd == 0x45 || cmd == 0x4F)
                indent += indenting;
            //              IF
            else if (cmd == 0x07) {
                // Verify if there is THEN
                var got_then = false;
                for(var l=k; l<end; l++)
                {
                    var op = a[j+l];
                    if( op == 0x1B ) {
                        got_then = true;
                        break;
                    }
                    else if( !op )
                        l++;
                    else if( op == 0x0F )
                        l+=a[j+l+1] + 1;
                    else if( op == 0x0E || op == 0x0D )
                        l+=6;
                }
                if (!got_then)
                    indent += indenting;
            }
            //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF
            else if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41)
                indent = indent > 0 ? indent - 1 : 0;

			while (k < end) {
				op = a[j+k++];
				switch (op) {
					case 0x0F: // SCONST
						var txt = '';
						var blen = a[j+k++];
						while (blen--) {
							c = a[j+k++];
							if (c == 0x9B)
								break;
							txt += String.fromCharCode(c);
						}
						s.tok.push(txt);
						line += '"' + txt + '"';
						break;
                    case 0x0D: // BCD hex const
                        var n = bcd(a,j+k);
                        var c = 1;
                        while (n >= (1 << c*8))
                            c++;
                        s.tok.push(n);
                        k += 6;
                        line += '$' + hex(n,c*2);
                        break;
					case 0x0E: // NCONST
						var n = bcd(a,j+k);
						s.tok.push(n);
						k += 6;
						line += n;
						break;
					case 0x16: // EOL
						k = end;
						break;
					default: {
                        var txt;
						if (op & 0x80)
							txt = b.variable_names[op&0x7F];
                        else if (!op) {
                            turbo = true;
                            txt = b.variable_names[a[j+k++] ^ 0x80];    // thx dragonstomper
                        } else {
                            if (op >= 85) {
                                turbo = true;
                                if (op >= 110)
                                    return failed("Unrecognized operation:" + op);    // not basic
                            }
							txt = _basic_operators[op];
                        }
                        if (txt == ":" || txt[0] == ' ')
                            line = line.trim();
						line += txt;
						s.tok.push(txt);
					}
				}
			}
		}
		b.statements.push(s);
		listing.push(line);
		j += len;
	}
	return {listing:listing,tokens:b}
}

//===================================================================================================
//===================================================================================================
// Atari syms

var _syms_zp = {
'00':["LINZBS","LINBUG STORAGE"],
'01':["NGFLAG",""],
'02':["CASINI","CASSETTE INIT LOC"],
'03':["CASINI+1",""],
'04':["RAMLO","RAM POINTER FOR MEM TEST"],
'05':["RAMLO+1",""],
'06':["TRAMSZ","TEMP LOC FOR RAM SIZE"],
'07':["TSTDAT","RAM TEST DATA LOC"],
'08':["WARMST","WARM START FLAG"],
'09':["BOOTQ","SUCCESSFUL BOOT FLAG"],
'0A':["DOSVEC","DOS START VECTOR"],
'0B':["DOSVEC+1",""],
'0C':["DOSINI","DOS INIT ADDRESS"],
'0D':["DOSINI+1",""],
'0E':["APPMHI","APPLICATION MEM HI LIMIT"],
'0F':["APPMHI+1",""],
'10':["POKMSK","SYSTEM MASK FOR POKEY IRQ ENABLE"],
'11':["BRKKEY","BREAK KEY FLAG"],
'12':["RTCLOK","REAL TIME CLOCK (60HZ OR 16.66666 MS)"],
'13':["RTCLOK+1",""],
'14':["RTCLOK+2",""],
'15':["BUFADR","INDIRECT BUFFER ADDRESS REG"],
'16':["BUFADR+1",""],
'17':["ICCOMT","COMMAND FOR VECTOR HANDLER"],
'18':["DSKFMS","DISK FILE MANAGER POINTER"],
'19':["DSKFMS+1",""],
'1A':["DSKUTL","DISK UTILITIES POINTER"],
'1B':["DSKUTL+1",""],
'1C':["PTIMOT","PRINTER TIME OUT REGISTER"],
'1D':["PBPNT","PRINT BUFFER POINTER"],
'1E':["PBUFSZ","PRINT BUFFER SIZE"],
'1F':["PTEMP","TEMP REG"],
'20':["ICHIDZ","HANDLER INDEX NUMBER ($FF := IOCB FREE)"],
'21':["ICDNOZ","DEVICE NUMBER (DRIVE NUMBER)"],
'22':["ICCOMZ","COMMAND CODE"],
'23':["ICSTAZ","STATUS OF LAST IOCB ACTION"],
'24':["ICBALZ","BUFFER ADDRESS (LOW)"],
'25':["ICBAHZ","BUFFER ADDRESS (HIGH)"],
'26':["ICPTLZ","PUT BYTE ROUTINE ADDRESS - 1"],
'27':["ICPTHZ",""],
'28':["ICBLLZ","BUFFER LENGTH (LOW)"],
'29':["ICBLHZ","BUFFER LENGTH (HIGH)"],
'2A':["ICAX1Z","AUX INFO"],
'2B':["ICAX2Z",""],
'2C':["ICSPRZ","SPARE BYTES (CIO LOCAL USE)"],
'2D':["ICSPRZ+1",""],
'2E':["ICIDNO","IOCB LUMBER * 16"],
'2F':["CIOCHR","CHARACTER BYTE FOR CURRENT OPERATION"],
'30':["STATUS","INTERNAL STATUS STORAGE"],
'31':["CHKSUM","CHECKSUM (SINGLE BYTE SUM WITH CARRY)"],
'32':["BUNRLO","POINTER TO DATA BUFFER (LO BYTE)"],
'33':["BUFRHI","POINTER TO DATA BUFFER (HI BYTE)"],
'34':["BFENLO","NEXT BYTE PAST END OF BUFFER (LO BYTE)"],
'35':["BNENHI","NEXT BYTE PAST END OF BUFFER (HI BYTE)"],
'36':["CRETRY","NUMBER OF COMMAND FRAM RETRIES"],
'37':["DRETRY","NUMBER OF DEVICE RETRIES"],
'38':["BUFRFL","DATA BUFFER FULL FLAG"],
'39':["RECVDN","RECEIVE DONE FLAG"],
'3A':["XMTDON","XMIT DONE FLAG"],
'3B':["CHKSNT","CHECKSUM SENT FLAG"],
'3C':["NOCKSM","NO CHECKSUM FOLLOWS DATA FLAG"],
'3D':["BPTR","BUFFER POINTER (CASSETTE)"],
'3E':["FTYPE","FILE TYPE (SHORT IRG/LONG IRG)"],
'3F':["FEOF","END OF FILE FLAG (CASSETTE)"],
'40':["FREQ","FREQ COUNTER FOR CONSOLE SPEAKER"],
'41':["SOUNDR","NOISY I/O FLAG. (ZERO IS QUIET)"],
'42':["CRITIC","CRITICAL CODE IF NON-ZERO)"],
'43':["FMSZPG","DISK FILE MANAGER SYSTEM STORAGE (7 BYTES)"],
'44':["FMSZPG+1",""],
'45':["FMSZPG+2",""],
'46':["FMSZPG+3",""],
'47':["FMSZPG+4",""],
'48':["FMSZPG+5",""],
'49':["FMSZPG+6",""],
'4A':["CKEY","SET WHEN GAME START PRESSED"],
'4B':["CASSBT","CASSETTE BOOT FLAG"],
'4C':["DSTAT","DISPLAY STATUS"],
'4D':["ATRACT","ATTRACT MODE FLAG"],
'4E':["DRKMSK","DARK ATTRACT MASK"],
'4F':["COLRSH","ATTRACT COLOR SHIFTER (XORED WITH PLAYFIELD)"],
'50':["TMPCHR","TEMP CHAR STORAGE (DISPLAY HANDLER)"],
'51':["HOLD1","TEMP STG (DISPLAY HANDLER)"],
'52':["LMARGN","LEFT MARGIN"],
'53':["RMARGN","RIGHT MARGIN"],
'54':["ROWCRS","CURSOR COUNTERS"],
'55':["COLCRS",""],
'56':["COLCRS+1",""],
'57':["DINDEX","DISPLAY INDEX (VARIOUS QUANTS)"],
'58':["SAVMSC",""],
'59':["SAVMSC+1",""],
'5A':["OLDROW","PREVIOUS ROW/COL"],
'5B':["OLDCOL",""],
'5C':["OLDCOL+1",""],
'5D':["OLDCHR","DATA UNDER CURSOR"],
'5E':["OLDADR",""],
'5F':["OLDADR+1",""],
'60':["NEWROW","POINT DRAWS TO HERE"],
'61':["NEWCOL",""],
'62':["PALNTS",""],
'63':["LOGCOL","POINTS AT COLUMN IN LOGICAL LINE"],
'64':["ADRESS","INDIRECT POINTER"],
'65':["ADRESS+1",""],
'66':["MLTTMP","MULTIPLY TEMP"],
'67':["TOADR+1",""],
'68':["SAVADR",""],
'69':["SAVADR+1",""],
'6A':["RAMTOP","RAM SIZE DEFINED BY POWER ON LOGIC"],
'6B':["BUFCNT","BUFFER COUNT"],
'6C':["BUFSTR","EDITOR GETCH POINTER"],
'6D':["BUFSTR+1",""],
'6E':["BITMSK","BIT MASK"],
'6F':["SHFAMT","OUTCHR SHIFT"],
'70':["ROWAC","USED BY \"DRAW\""],
'71':["ROWAC+1",""],
'72':["COLAC",""],
'73':["COLAC+1",""],
'74':["ENDPT",""],
'75':["ENDPT+1",""],
'76':["DELTAR",""],
'77':["DELTAC",""],
'78':["DELTAC+1",""],
'79':["ROWINC",""],
'7A':["COLINC",""],
'7B':["SWPFLG","NON-0 IF TXT AND RAM SWAPPED"],
'7C':["HOLDCH","CH BEFORE CNTL & SHFT PROCESSING IN KGETCH"],
'7D':["INSDAT","INSERT CHAR SAVE"],
'7E':["COUNTR","DRAW COUNTER"],
'7F':["COUNTR+1",""],
'80':["LOMEM","BASIC POINTER TO LOW MEMORY"],
'81':["LOMEM+1",""],
'82':["VNTP","BASIC VARIABLE NAME TABLE"],
'83':["VNTP+1",""],
'84':["VNTD","BASIC VARIABLE NAME TABLE END"],
'85':["VNTD+1",""],
'86':["VVTP","BASIC VARIABLE VALUE TABLE"],
'87':["VVTP+1",""],
'88':["STMTAB","BASIC STATEMENT TABLE"],
'89':["STMTAB+1",""],
'8A':["STMCUR","BASIC CURRENT STATEMENT POINTER"],
'8B':["STMCUR+1",""],
'8C':["STARP","BASIC STRING AND ARRAY POINTER"],
'8D':["STARP+1",""],
'8E':["RUNSTK","BASIC RUNTIME STACK"],
'8F':["RUNSTK+1",""],
'90':["MEMTOP","BASIC TOP OF MEMORY"],
'91':["MEMTOP+1",""],
'92':["MEOLFLG",""],
'94':["COX",""],
'95':["POKADR",""],
'96':["POKADR+1",""],
'97':["SVESA",""],
'98':["SVESA+1",""],
'99':["MVFA",""],
'9A':["MVFA+1",""],
'9B':["MVTA",""],
'9C':["MVTA+1",""],
'9D':["CPC",""],
'9E':["CPC+1",""],
'9F':["LLNGTH",""],
'A0':["TSLNUM",""],
'A1':["TSLNUM+1",""],
'A2':["MVLNG",""],
'A3':["MVLNG+1",""],
'A4':["ECSIZE",""],
'A5':["ECSIZE+1",""],
'A6':["DIRFLG",""],
'A7':["STMLBD",""],
'A8':["STINDEX",""],
'A9':["OPSTKX",""],
'AA':["ARSTKX",""],
'AB':["EXSVOP",""],
'AC':["EXSVPR",""],
'AD':["LELNUM",""],
'AE':["LELNUM+1",""],
'AF':["STENUM",""],
'B0':["COMCNT",""],
'B1':["ADFLAG",""],
'B2':["SVDISP",""],
'B3':["ONLOOP",""],
'B4':["ENTDTD",""],
'B5':["LISTDTD",""],
'B6':["DATAD",""],
'B7':["DATALN",""],
'B8':["DATALN+1",""],
'B9':["ERRNUM",""],
'BA':["STOPLN",""],
'BB':["STOPLN+1",""],
'BC':["TRAPLN",""],
'BD':["TRAPLN+1",""],
'BE':["SAVCUR",""],
'BF':["SAVCUR+1",""],
'C0':["IOCMD",""],
'C1':["IODVC",""],
'C2':["PROMPT",""],
'C3':["ERRSAV",""],
'C4':["TEMPA",""],
'C5':["TEMPA+1",""],
'C6':["ZTEMP2",""],
'C7':["ZTEMP2+1",""],
'C8':["COLOR",""],
'C9':["PTABW",""],
'CA':["LOADFLG",""],
'D2':["VTYPE",""],
'D3':["VNUM",""],
'D4':["FR0",""],
'D5':["FR0+1",""],
'D6':["FR0+2",""],
'D7':["FR0+3",""],
'D8':["FR0+4",""],
'D9':["FR0+5",""],
'DA':["FRE",""],
'DB':["FRE+1",""],
'DC':["FRE+2",""],
'DD':["FRE+3",""],
'DE':["FRE+4",""],
'DF':["FRE+5",""],
'E0':["FR1",""],
'E1':["FR1+1",""],
'E2':["FR1+2",""],
'E3':["FR1+3",""],
'E4':["FR1+4",""],
'E5':["FR1+5",""],
'E6':["FR2",""],
'E7':["FR2+1",""],
'E8':["FR2+2",""],
'E9':["FR2+3",""],
'EA':["FR2+4",""],
'EB':["FR2+5",""],
'EC':["FRX",""],
'ED':["EEXP",""],
'EE':["NSIGN",""],
'EF':["ESIGN",""],
'F0':["FCHRFLG",""],
'F1':["DIGRT",""],
'F2':["CIX",""],
'F3':["INBUFF",""],
'F4':["INBUFF+1",""],
'F5':["ZTEMP1",""],
'F6':["ZTEMP1+1",""],
'F7':["ZTEMP4",""],
'F8':["ZTEMP4+1",""],
'F9':["ZTEMP3",""],
'FA':["ZTEMP3+1",""],
'FB':["RADFLG",""],
'FC':["FLPTR",""],
'FD':["FLPTR+1",""],
'FE':["FPTR2",""],
'FF':["FPTR2+1",""]
}

var _syms_ = {
'0200':["VDSLST","DISPLAY LIST NMI VECTOR"],
'0201':["VDSLST+1",""],
'0202':["VPRCED","PROCEED LINE IRQ VECTOR"],
'0203':["VPRCED+1",""],
'0204':["VINTER","INTERRUPT LINE IRQ VECTOR"],
'0205':["VINTER+1",""],
'0206':["VBREAK","\"BRK\" VECTOR"],
'0207':["VBREAK+1",""],
'0208':["VKEYBD","POKEY KEYBOARD IRQ VECTOR"],
'0209':["VKEYBD+1",""],
'020A':["VSERIN","POKEY SERIAL INPUT READY"],
'020B':["VSERIN+1",""],
'020C':["VSEROR","POKEY SERIAL OUTPUT READY"],
'020D':["VSEROR+1",""],
'020E':["VSEROC","POKEY SERIAL OUTPUT DONE"],
'020F':["VSEROC+1",""],
'0210':["VTIMR1","POKEY TIMER 1 IRQ"],
'0211':["VTIMR1+1",""],
'0212':["VTIMR2","POKEY TIMER 2 IRQ"],
'0213':["VTIMR2+1",""],
'0214':["VTIMR4","POKEY TIMER 4 IRQ (DO NOT USE)"],
'0215':["VTIMR4+1",""],
'0216':["VIMIRQ","IMMEDIATE IRQ VECTOR"],
'0217':["VIMIRQ+1",""],
'0218':["CDTMV1","COUNT DOWN TIMER 1"],
'0219':["CDTMV1+1",""],
'021A':["CDTMV1","COUNT DOWN TIMER 2"],
'021B':["CDTMV2+1",""],
'021C':["CDTMV1","COUNT DOWN TIMER 3"],
'021D':["CDTMV3+1",""],
'021E':["CDTMV1","COUNT DOWN TIMER 4"],
'021F':["CDTMV4+1",""],
'0220':["CDTMV1","COUNT DOWN TIMER 5"],
'0221':["CDTMV5+1",""],
'0222':["VVBLKI","IMMEDIATE VERTICAL BLANK NMI VECTOR"],
'0223':["VVBLKI+1",""],
'0224':["VVBLKD","DEFERRED VERTICAL BLANK NMI VECTOR"],
'0225':["VVBLKD+1",""],
'0226':["CDTMA1","COUNT DOWN TIMER 1 JSR ADDRESS"],
'0227':["CDTMA1+1",""],
'0228':["CDTMA2","COUNT DOWN TIMER 2 JSR ADDRESS"],
'0229':["CDTMA2+1",""],
'022A':["CDTMF3","COUNT DOWN TIMER 3 FLAG"],
'022B':["SRTIMR","SOFTWARE REPEAT TIMER"],
'022C':["CDTMF4","COUNT DOWN TIMER 4 FLAG"],
'022D':["INTEMP","IANS TEMP (???)"],
'022E':["CDTMF5","COUNT DOWN TIMER 5 FLAG"],
'022F':["SDMCTL","SAVE DMACTL REGISTER"],
'0230':["SDLSTL","SAVE DISPLAY LIST (LOW)"],
'0231':["SDLSTH","SAVE DISPLAY LIST (HIGH)"],
'0232':["SSKCTL","SKCTL REGISTER RAM"],
'0233':["LCOUNT",""],
'0234':["LPENH","LIGHT PEN HORIZ VALUE"],
'0235':["LPENV","LIGHT PEN VERT VALUE"],
'0236':["BRKKY",""],
'0237':["BRKKY+1",""],
'0238':["VPIRQ",""],
'0239':["VPIRQ+1",""],
'023A':["CDEVIC","COMMAND FRAME BUFFER - DEVICE"],
'023B':["CCOMND","COMMAND"],
'023C':["CAUX1","COMMAND AUX BYTE 1"],
'023D':["CAUX2","COMMAND AUX BYTE 2"],
'023E':["TEMP",""],
'023F':["ERRFLG","ERROR FLAG - ANY DEVICE ERROR EXCEPT TIMEOUT"],
'0240':["DFLAGS","DISK FLAGS FROM SECTOR ONE"],
'0241':["DBSECT","NUMBER OF DISK BOOT SECTORS"],
'0242':["BOOTAD","ADDRESS FOR DISK BOOT LOADER"],
'0243':["BOOTAD+1",""],
'0244':["COLDST","COLDSTART FLAG (1 = DOING COLDSTART)"],
'0245':["RECLEN",""],
'0246':["DSKTIM","DISK TIME OUT REG"],
'0247':["LINBUF","CHAR LINE BUFFER (40 BYTES)"],
'0248':["SHPDVS",""],
'0249':["PDIMSK",""],
'024A':["RELADR",""],
'024B':["RELADR+1",""],
'024C':["PPTMPA",""],
'024D':["PPTMPX",""],
'026B':["CHSALT",""],
'026C':["VSFLAG",""],
'026D':["KEYDIS",""],
'026E':["FINE",""],
'026F':["GPRIOR","GLOBAL PRIORITY CELL"],
'0270':["PADDL0","POT 0 SHADOW"],
'0271':["PADDL1","POT 1 SHADOW"],
'0272':["PADDL2","POT 2 SHADOW"],
'0273':["PADDL3","POT 3 SHADOW"],
'0274':["PADDL4","POT 4 SHADOW"],
'0275':["PADDL5","POT 5 SHADOW"],
'0276':["PADDL6","POT 6 SHADOW"],
'0277':["PADDL7","POT 7 SHADOW"],
'0278':["STICK0","JOYSTICK 0 SHADOW"],
'0279':["STICK1","JOYSTICK 1 SHADOW"],
'027A':["STICK2","JOYSTICK 2 SHADOW"],
'027B':["STICK3","JOYSTICK 3 SHADOW"],
'027C':["PTRIG0","PADDLE 0 TRIGGER"],
'027D':["PTRIG1","PADDLE 1 TRIGGER"],
'027E':["PTRIG2","PADDLE 2 TRIGGER"],
'027F':["PTRIG3","PADDLE 3 TRIGGER"],
'0280':["PTRIG4","PADDLE 4 TRIGGER"],
'0281':["PTRIG5","PADDLE 5 TRIGGER"],
'0282':["PTRIG6","PADDLE 6 TRIGGER"],
'0283':["PTRIG7","PADDLE 7 TRIGGER"],
'0284':["STRIG0","JOYSTICK 0 TRIGGER"],
'0285':["STRIG1","JOYSTICK 1 TRIGGER"],
'0286':["STRIG2","JOYSTICK 2 TRIGGER"],
'0287':["STRIG3","JOYSTICK 3 TRIGGER"],
'0288':["CSTAT","(UNUSED)"],
'0289':["WMODE","R/W FLAG FOR CASSETTE"],
'028A':["BLIM","BUFFER LIMIT (CASSETTE)"],
'028B':["IMASK",""],
'028C':["JVECK",""],
'028D':["JVECK+1",""],
'028E':["NEWADR",""],
'028F':["NEWADR+1",""],
'0290':["TXTROW","TEXT ROWCRS"],
'0291':["TXTCOL","TEXT ROWCOL"],
'0292':["TXTCOL+1",""],
'0293':["TINDEX","TEXT INDEX"],
'0294':["TXTMSC","FOOLS CONVRT INTO NEW MSC"],
'0295':["TXTMSC+1",""],
'0296':["TXTOLD","OLDROW AND OLDCOL FOR TEXT (AND THEN SOME)"],
'0297':["TXTOLD+1",""],
'0298':["TXTOLD+2",""],
'0299':["TXTOLD+3",""],
'029A':["TXTOLD+4",""],
'029B':["TXTOLD+5",""],
'029C':["TMPX1",""],
'029D':["HOLD3",""],
'029E':["SUBTMP",""],
'029F':["HOLD2",""],
'02A0':["DMASK",""],
'02A1':["TMPLBT",""],
'02A2':["ESCFLG","ESCAPE FLAG"],
'02A3':["TABMAP","TAB BUFFER"],
'02A4':["TABMAP+1",""],
'02A5':["TABMAP+2",""],
'02A6':["TABMAP+3",""],
'02A7':["TABMAP+4",""],
'02A8':["TABMAP+5",""],
'02A9':["TABMAP+6",""],
'02AA':["TABMAP+7",""],
'02AB':["TABMAP+8",""],
'02AC':["TABMAP+9",""],
'02AD':["TABMAP+A",""],
'02AE':["TABMAP+B",""],
'02AF':["TABMAP+C",""],
'02B0':["TABMAP+D",""],
'02B1':["TABMAP+E",""],
'02B2':["LOGMAP","LOGICAL LINE START BIT MAP"],
'02B3':["LOGMAP+1",""],
'02B4':["LOGMAP+2",""],
'02B5':["LOGMAP+3",""],
'02B6':["INVFLG","INVERSE VIDEO FLAG (ATARI KEY)"],
'02B7':["FILFLG","RIGHT FILL FLAG FOR DRAW"],
'02B8':["TMPROW",""],
'02B9':["TMPCOL",""],
'02BA':["TMPCOL+1",""],
'02BB':["SCRFLG","SET IF SCROLL OCCURS"],
'02BC':["HOLD4","MORE DRAW TEMPS"],
'02BD':["HOLD5",""],
'02BE':["SHFLOK","SHIFT LOCK KEY"],
'02BF':["BOTSCR","BOTTOM OF SCREEN (24 NORM, 4 SPLIT)"],
'02C0':["PCOLR0","P0 COLOR"],
'02C1':["PCOLR1","P1 COLOR"],
'02C2':["PCOLR2","P2 COLOR"],
'02C3':["PCOLR3","P3 COLOR"],
'02C4':["COLOR0","COLOR 0"],
'02C5':["COLOR1",""],
'02C6':["COLOR2",""],
'02C7':["COLOR3",""],
'02C8':["COLOR4","BACKGROUND"],
'02C9':["RUNADR",""],
'02CA':["RUNADR+1",""],
'02CB':["HIUSED",""],
'02CC':["HIUSED+1",""],
'02CD':["ZHIUSE",""],
'02CE':["ZHIUSE+1",""],
'02CF':["GBYTEA",""],
'02D0':["GBYTEA+1",""],
'02D1':["LOADAD",""],
'02D2':["LOADAD+1",""],
'02D3':["ZLOADA",""],
'02D4':["ZLOADA+1",""],
'02D5':["DSCTLN",""],
'02D6':["DSCTLN+1",""],
'02D7':["ACMISR",""],
'02D8':["ACMISR+1",""],
'02D9':["KRPDEL",""],
'02DA':["KEYREP",""],
'02DB':["NOCLIK",""],
'02DC':["HELPFG",""],
'02DD':["DMASAV",""],
'02DE':["PBPNT",""],
'02DF':["PBUFSZ",""],
'02E0':["RUNAD","DOS RUN ADDRESS"],
'02E1':["RUNAD+1",""],
'02E2':["INITAD","DOS INIT ADDRESS"],
'02E3':["INITAD+1",""],
'02E4':["RAMSIZ","RAM SIZE (HI BYTE ONLY)"],
'02E5':["MEMTOP","TOP OF AVAILABLE MEMORY"],
'02E6':["MEMTOP+1",""],
'02E7':["MEMLO","BOTTOM OF AVAILABLE MEMORY"],
'02E8':["MEMLO+1",""],
'02E9':["HNDLOD",""],
'02EA':["DVSTAT","STATUS BUFFER"],
'02EB':["DVSTAT+1",""],
'02EC':["DVSTAT+2",""],
'02ED':["DVSTAT+3",""],
'02EE':["CBAUDL","CASSETTE BAUD RATE (LO BYTE)"],
'02EF':["CBAUDH","CASSETTE BAUD RATE (HI BYTE)"],
'02F0':["CRSINH","CURSOR INHIBIT (00 = CURSOR ON)"],
'02F1':["KEYDEL","KEY DELAY"],
'02F2':["CH1",""],
'02F3':["CHACT","CHACTL REGISTER (SHADOW)"],
'02F4':["CHBAS","CHBAS REGISTER (SHADOW)"],
'02F5':["NEWROW",""],
'02F6':["NEWCOL",""],
'02F7':["NEWCOL+1",""],
'02F8':["ROWINC",""],
'02F9':["COLINC",""],
'02FA':["CHAR",""],
'02FB':["ATACHR","ATASCII CHARACTER"],
'02FC':["CH","GLOBAL VARIABLE FOR KEYBOARD"],
'02FD':["FILDAT","RIGHT FILL DATA (DRAW)"],
'02FE':["DSPFLG","DISPLAY FLAG: DISP CONTROLS IF NON-ZERO"],
'02FF':["SSFLAG","START/STOP FLAG (CNTL-1) FOR PAGING"],
'0300':["DDEVIC","BUS I.D. NUMBER"],
'0301':["DUNIT","UNIT NUMBER"],
'0302':["DCOMND","BUS COMMAND"],
'0303':["DSTATS","COMMAND TYPE/STATUS RETURN"],
'0304':["DBUFLO","DATA BUFFER POINTER"],
'0305':["DBUFHI","..."],
'0306':["DTIMLO","DEVICE TIME OUT IN 1 SEC. UNITS"],
'0307':["DUNUSE","UNUSED"],
'0308':["DBYTLO","BYTE COUNT"],
'0309':["DBYTHI","..."],
'030A':["DAUX1","COMMAND AUXILLARY BYTES"],
'030B':["DAUX2","..."],
'030C':["TIMER1","INITIAL TIMER VALUE"],
'030D':["TIMER1+1",""],
'030E':["ADDCOR","ADDITION CORRECTION"],
'030F':["CASFLG","CASSETTE MODE WHEN SET"],
'0310':["TIMER2","FINAL TIME VALUE (USED TO COMPUTE BAUD RATE)"],
'0311':["TIMER2+1",""],
'0312':["TEMP1","TEMP LOCATIONS"],
'0313':["TEMP2",""],
'0314':["TEMP2","..."],
'0315':["TEMP3","..."],
'0316':["SAVIO","SAVE SERIAL IN DATA PORT"],
'0317':["TIMFLG","TIME OUT FLAG FOR BAUD RATE CORRECTION"],
'0318':["STACKP","SIO STACK POINTER SAVE LOC"],
'0319':["TSTAT","TEMP STATUS LOC"],
'031A':["HATABS","HANDLER ADDRESS TABLE"],
'033D':["PUPBT1",""],
'033E':["PUPBT2",""],
'033F':["PUPBT3",""],
'0340':["IOCB0","I/O CONTROL BLOCK 0"],
'0341':["ICDNO","DEVICE NUMBER (DRIVE NUMBER)"],
'0342':["ICCOM","COMMAND CODE"],
'0343':["ICSTA","STATUS"],
'0344':["ICBAL","BUFFER ADDRESS"],
'0345':["ICBAH","..."],
'0346':["ICPTL","PUT BYTE ROUTINE ADDRESS - 1"],
'0347':["ICPTH","..."],
'0348':["ICBLL","BUFFER LENGTH"],
'0349':["ICBLH","..."],
'034A':["ICAX1","AUXILLARY INFO"],
'034B':["ICAX2","..."],
'034C':["ICSPR","4 SPARE BYTES"],
'034D':["B0-ICAX4",""],
'034E':["B0-ICAX5",""],
'034F':["B0-ICAX6",""],
'0350':["IOCB1","I/O CONTROL BLOCK 1"],
'0351':["B1-ICDNO",""],
'0352':["B1-ICCOM",""],
'0353':["B1-ICSTA",""],
'0354':["B1-ICBAL",""],
'0355':["B1-ICBAH",""],
'0356':["B1-ICPTL",""],
'0357':["B1-ICPTH",""],
'0358':["B1-ICBLL",""],
'0359':["B1-ICBLH",""],
'035A':["B1-ICAX1",""],
'035B':["B1-ICAX2",""],
'035C':["B1-ICAX3",""],
'035D':["B1-ICAX4",""],
'035E':["B1-ICAX5",""],
'035F':["B1-ICAX6",""],
'0360':["IOCB2","I/O CONTROL BLOCK 2"],
'0361':["B2-ICDNO",""],
'0362':["B2-ICCOM",""],
'0363':["B2-ICSTA",""],
'0364':["B2-ICBAL",""],
'0365':["B2-ICBAH",""],
'0366':["B2-ICPTL",""],
'0367':["B2-ICPTH",""],
'0368':["B2-ICBLL",""],
'0369':["B2-ICBLH",""],
'036A':["B2-ICAX1",""],
'036B':["B2-ICAX2",""],
'036C':["B2-ICAX3",""],
'036D':["B2-ICAX4",""],
'036E':["B2-ICAX5",""],
'036F':["B2-ICAX6",""],
'0370':["IOCB3","I/O CONTROL BLOCK 3"],
'0371':["B3-ICDNO",""],
'0372':["B3-ICCOM",""],
'0373':["B3-ICSTA",""],
'0374':["B3-ICBAL",""],
'0375':["B3-ICBAH",""],
'0376':["B3-ICPTL",""],
'0377':["B3-ICPTH",""],
'0378':["B3-ICBLL",""],
'0379':["B3-ICBLH",""],
'037A':["B3-ICAX1",""],
'037B':["B3-ICAX2",""],
'037C':["B3-ICAX3",""],
'037D':["B3-ICAX4",""],
'037E':["B3-ICAX5",""],
'037F':["B3-ICAX6",""],
'0380':["IOCB4","I/O CONTROL BLOCK 4"],
'0381':["B4-ICDNO",""],
'0382':["B4-ICCOM",""],
'0383':["B4-ICSTA",""],
'0384':["B4-ICBAL",""],
'0385':["B4-ICBAH",""],
'0386':["B4-ICPTL",""],
'0387':["B4-ICPTH",""],
'0388':["B4-ICBLL",""],
'0389':["B4-ICBLH",""],
'038A':["B4-ICAX1",""],
'038B':["B4-ICAX2",""],
'038C':["B4-ICAX3",""],
'038D':["B4-ICAX4",""],
'038E':["B4-ICAX5",""],
'038F':["B4-ICAX6",""],
'0390':["IOCB5","I/O CONTROL BLOCK 5"],
'0391':["B5-ICDNO",""],
'0392':["B5-ICCOM",""],
'0393':["B5-ICSTA",""],
'0394':["B5-ICBAL",""],
'0395':["B5-ICBAH",""],
'0396':["B5-ICPTL",""],
'0397':["B5-ICPTH",""],
'0398':["B5-ICBLL",""],
'0399':["B5-ICBLH",""],
'039A':["B5-ICAX1",""],
'039B':["B5-ICAX2",""],
'039C':["B5-ICAX3",""],
'039D':["B5-ICAX4",""],
'039E':["B5-ICAX5",""],
'039F':["B5-ICAX6",""],
'03A0':["IOCB6","I/O CONTROL BLOCK 6"],
'03A1':["B6-ICDNO",""],
'03A2':["B6-ICCOM",""],
'03A3':["B6-ICSTA",""],
'03A4':["B6-ICBAL",""],
'03A5':["B6-ICBAH",""],
'03A6':["B6-ICPTL",""],
'03A7':["B6-ICPTH",""],
'03A8':["B6-ICBLL",""],
'03A9':["B6-ICBLH",""],
'03AA':["B6-ICAX1",""],
'03AB':["B6-ICAX2",""],
'03AC':["B6-ICAX3",""],
'03AD':["B6-ICAX4",""],
'03AE':["B6-ICAX5",""],
'03AF':["B6-ICAX6",""],
'03B0':["IOCB7","I/O CONTROL BLOCK 7"],
'03B1':["B7-ICDNO",""],
'03B2':["B7-ICCOM",""],
'03B3':["B7-ICSTA",""],
'03B4':["B7-ICBAL",""],
'03B5':["B7-ICBAH",""],
'03B6':["B7-ICPTL",""],
'03B7':["B7-ICPTH",""],
'03B8':["B7-ICBLL",""],
'03B9':["B7-ICBLH",""],
'03BA':["B7-ICAX1",""],
'03BB':["B7-ICAX2",""],
'03BC':["B7-ICAX3",""],
'03BD':["B7-ICAX4",""],
'03BE':["B7-ICAX5",""],
'03BF':["B7-ICAX6",""],
'03C0':["PRNBUF","PRINTER BUFFER"],
'03E8':["SUPERF",""],
'03E9':["CKEY",""],
'03EA':["CASSBT",""],
'03EB':["CARTCK",""],
'03EC':["DERRF",""],
'03ED':["ACMVAR",""],
'03F8':["BASICF",""],
'03F9':["MINTLK",""],
'03FA':["GINTLK",""],
'03FB':["CHLINK",""],
'03FC':["CHLINK+1",""],
'03FD':["CASBUF","CASSETTE BUFFER"],
'9FFA':["R-CARTCS",""],
'9FFB':["R-CARTCS+1",""],
'9FFC':["R-CART",""],
'9FFD':["R-CARTFG",""],
'9FFE':["R-CARTAD",""],
'9FFF':["R-CARTAD+1",""],
'BFFA':["CARTCS",""],
'BFFB':["CARTCS+1",""],
'BFFC':["CART",""],
'BFFD':["CARTFG",""],
'BFFE':["CARTAD",""],
'BFFF':["CARTAD+1",""],
'D000':["M0PF",""],
'D001':["M1PF",""],
'D002':["M2PF",""],
'D003':["M3PF",""],
'D004':["P0PF",""],
'D005':["P1PF",""],
'D006':["P2PF",""],
'D007':["P3PF",""],
'D008':["M0PL",""],
'D009':["M1PL",""],
'D00A':["M2PL",""],
'D00B':["M3PL",""],
'D00C':["P0PL",""],
'D00D':["P1PL",""],
'D00E':["P2PL",""],
'D00F':["P3PL",""],
'D010':["TRIG0",""],
'D011':["TRIG1",""],
'D012':["TRIG2",""],
'D013':["TRIG3",""],
'D014':["PAL",""],
'D015':["COLPM3",""],
'D016':["COLPF0",""],
'D017':["COLPF1",""],
'D018':["COLPF2",""],
'D019':["COLPF3",""],
'D01A':["COLBK",""],
'D01B':["PRIOR",""],
'D01C':["VDELAY",""],
'D01D':["GRACTL",""],
'D01E':["HITCLR",""],
'D01F':["CONSOL",""],
'D100':["PBI",""],
'D1FF':["PDVI",""],
'D200':["POT0",""],
'D201':["POT1",""],
'D202':["POT2",""],
'D203':["POT3",""],
'D204':["POT4",""],
'D205':["POT5",""],
'D206':["POT6",""],
'D207':["POT7",""],
'D208':["ALLPOT",""],
'D209':["KBCODE",""],
'D20A':["RANDOM",""],
'D20B':["POTGO",""],
'D20D':["SERIN",""],
'D20E':["IRQST",""],
'D20F':["SKSTAT",""],
'D300':["PORTA",""],
'D301':["PORTB",""],
'D302':["PACTL",""],
'D303':["PBCTL",""],
'D400':["DMACTL",""],
'D401':["CHACTL",""],
'D402':["DLISTL",""],
'D403':["DLISTH",""],
'D404':["HSCROL",""],
'D405':["VSCROL",""],
'D407':["PMBASE",""],
'D409':["CHBASE",""],
'D40A':["WSYNC",""],
'D40B':["VCOUNT",""],
'D40C':["PENH",""],
'D40D':["PENV",""],
'D40E':["NMIEN",""],
'D40F':["NMIST",""],
'D600':["PBIRAM",""],
'D800':["AFP",""],
'D803':["PDID1",""],
'D805':["PDIOV",""],
'D806':["PDIOV+1",""],
'D808':["PDIRQV",""],
'D809':["PDIRQV+1",""],
'D80B':["PDID2",""],
'D80D':["PDVV",""],
'D8E6':["FASC",""],
'D9AA':["IFP",""],
'D9D2':["FPI",""],
'DA44':["ZFR0",""],
'DA46':["ZF1",""],
'DA60':["FSUB",""],
'DA66':["FADD",""],
'DADB':["FMUL",""],
'DB28':["FDIV",""],
'DD40':["PLYEVL",""],
'DD89':["FLD0R",""],
'DD8D':["FLD0P",""],
'DD98':["FLD1R",""],
'DD9C':["FLD1P",""],
'DDA7':["FST0R",""],
'DDAB':["FST0P",""],
'DDB6':["FMOVE",""],
'DDC0':["EXP",""],
'DDCC':["EXP10",""],
'DECD':["LOG",""],
'DED1':["LOG10",""],
'E400':["EDITRV","EDITOR"],
'E410':["SCRENV","TELEVISION SCREEN"],
'E420':["KEYBDV","KEYBOARD"],
'E430':["PRINTV","PRINTER"],
'E440':["CASETV","CASSETTE"],
'E450':["DISKIV","DISK INITIALIZATION"],
'E453':["DSKINV","DISK INTERFACE"],
'E456':["CIOV","CIO ROUTINE"],
'E459':["SIOV","SIO ROUTINE"],
'E45C':["SETVBV","SET VERTICAL BLANK VECTORS"],
'E45F':["SYSVBV","SYSTEM VERTICAL BLANK ROUTINE"],
'E462':["XITVBV","EXIT VERTICAL BLANK ROUTINE"],
'E465':["SIOINV","SIO INIT"],
'E468':["SENDEV","SEND ENABLE ROUTINE"],
'E46B':["INTINV","INTERRUPT HANDLER INIT"],
'E46E':["CIOINV","CIO INIT"],
'E471':["BLKBDV","BLACKBOARD MODE"],
'E474':["WARMSV","WARM START ENTRY POINT"],
'E477':["COLDSV","COLD START ENTRY POINT"],
'E47A':["RBLOKV",""],
'E47D':["RBLOKV","CASSETTE READ BLOCK VECTOR"],
'E480':["DSOPIV","CASSETTE OPEN FOR INPUT VECTOR"],
'E483':["SLFTSV",""],
'E486':["PHENTV",""],
'E489':["PHUNLV",""],
'E48C':["PHINIV",""],
'E48F':["GPDVV",""],
'F385':["PUTLIN","OUTPUT LINE TO IOCB#0"],
'F6A4':["EOUTCH","OUTPUT CHAR TO SCREEN"],
'F6E2':["KGETCH","GET CHAR FROM KEYBOARD"]
}

//===================================================================================================
//===================================================================================================
// 6502 disassembler derived from
// n. landsteiner, mass:werk / electronic tradion 2005; e-tradion.net

var opctab= [
    ['BRK','imp'], ['ORA','inx'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ORA','zpg'], ['ASL','zpg'], ['???','imp'],
    ['PHP','imp'], ['ORA','imm'], ['ASL','acc'], ['???','imp'],
    ['???','imp'], ['ORA','abs'], ['ASL','abs'], ['???','imp'],
    ['BPL','rel'], ['ORA','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ORA','zpx'], ['ASL','zpx'], ['???','imp'],
    ['CLC','imp'], ['ORA','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ORA','abx'], ['ASL','abx'], ['???','imp'],
    ['JSR','abs'], ['AND','inx'], ['???','imp'], ['???','imp'],
    ['BIT','zpg'], ['AND','zpg'], ['ROL','zpg'], ['???','imp'],
    ['PLP','imp'], ['AND','imm'], ['ROL','acc'], ['???','imp'],
    ['BIT','abs'], ['AND','abs'], ['ROL','abs'], ['???','imp'],
    ['BMI','rel'], ['AND','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['AND','zpx'], ['ROL','zpx'], ['???','imp'],
    ['SEC','imp'], ['AND','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['AND','abx'], ['ROL','abx'], ['???','imp'],
    ['RTI','imp'], ['EOR','inx'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['EOR','zpg'], ['LSR','zpg'], ['???','imp'],
    ['PHA','imp'], ['EOR','imm'], ['LSR','acc'], ['???','imp'],
    ['JMP','abs'], ['EOR','abs'], ['LSR','abs'], ['???','imp'],
    ['BVC','rel'], ['EOR','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['EOR','zpx'], ['LSR','zpx'], ['???','imp'],
    ['CLI','imp'], ['EOR','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['EOR','abx'], ['LSR','abx'], ['???','imp'],
    ['RTS','imp'], ['ADC','inx'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ADC','zpg'], ['ROR','zpg'], ['???','imp'],
    ['PLA','imp'], ['ADC','imm'], ['ROR','acc'], ['???','imp'],
    ['JMP','ind'], ['ADC','abs'], ['ROR','abs'], ['???','imp'],
    ['BVS','rel'], ['ADC','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ADC','zpx'], ['ROR','zpx'], ['???','imp'],
    ['SEI','imp'], ['ADC','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ADC','abx'], ['ROR','abx'], ['???','imp'],
    ['???','imp'], ['STA','inx'], ['???','imp'], ['???','imp'],
    ['STY','zpg'], ['STA','zpg'], ['STX','zpg'], ['???','imp'],
    ['DEY','imp'], ['???','imp'], ['TXA','imp'], ['???','imp'],
    ['STY','abs'], ['STA','abs'], ['STX','abs'], ['???','imp'],
    ['BCC','rel'], ['STA','iny'], ['???','imp'], ['???','imp'],
    ['STY','zpx'], ['STA','zpx'], ['STX','zpy'], ['???','imp'],
    ['TYA','imp'], ['STA','aby'], ['TXS','imp'], ['???','imp'],
    ['???','imp'], ['STA','abx'], ['???','imp'], ['???','imp'],
    ['LDY','imm'], ['LDA','inx'], ['LDX','imm'], ['???','imp'],
    ['LDY','zpg'], ['LDA','zpg'], ['LDX','zpg'], ['???','imp'],
    ['TAY','imp'], ['LDA','imm'], ['TAX','imp'], ['???','imp'],
    ['LDY','abs'], ['LDA','abs'], ['LDX','abs'], ['???','imp'],
    ['BCS','rel'], ['LDA','iny'], ['???','imp'], ['???','imp'],
    ['LDY','zpx'], ['LDA','zpx'], ['LDX','zpy'], ['???','imp'],
    ['CLV','imp'], ['LDA','aby'], ['TSX','imp'], ['???','imp'],
    ['LDY','abx'], ['LDA','abx'], ['LDX','aby'], ['???','imp'],
    ['CPY','imm'], ['CMP','inx'], ['???','imp'], ['???','imp'],
    ['CPY','zpg'], ['CMP','zpg'], ['DEC','zpg'], ['???','imp'],
    ['INY','imp'], ['CMP','imm'], ['DEX','imp'], ['???','imp'],
    ['CPY','abs'], ['CMP','abs'], ['DEC','abs'], ['???','imp'],
    ['BNE','rel'], ['CMP','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['CMP','zpx'], ['DEC','zpx'], ['???','imp'],
    ['CLD','imp'], ['CMP','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['CMP','abx'], ['DEC','abx'], ['???','imp'],
    ['CPX','imm'], ['SBC','inx'], ['???','imp'], ['???','imp'],
    ['CPX','zpg'], ['SBC','zpg'], ['INC','zpg'], ['???','imp'],
    ['INX','imp'], ['SBC','imm'], ['NOP','imp'], ['???','imp'],
    ['CPX','abs'], ['SBC','abs'], ['INC','abs'], ['???','imp'],
    ['BEQ','rel'], ['SBC','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['SBC','zpx'], ['INC','zpx'], ['???','imp'],
    ['SED','imp'], ['SBC','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['SBC','abx'], ['INC','abx'], ['???','imp']
];

var addrtab= {
    acc:'A',
    abs:'abs',
    abx:'abs,X',
    aby:'abs,Y',
    imm:'#',
    imp:'impl',
    ind:'ind',
    inx:'X,ind',
    iny:'ind,Y',
    rel:'rel',
    zpg:'zpg',
    zpx:'zpg,X',
    zpy:'zpg,Y'
}

var steptab = {
    imp:1,
    acc:1,
    imm:2,
    abs:3,
    abx:3,
    aby:3,
    zpg:2,
    zpx:2,
    zpy:2,
    ind:3,
    inx:2,
    iny:2,
    rel:2
};

// functions
function disassembleStep(pc,ram,asm,flags)
{
    var instr, op1, op2, addr, ops, disas, adm, step;
    var symbol;

    // get instruction and ops, inc pc
    function u8(i) {
        return ram[i];
    }
    instr=u8(pc);
    addr=hex(pc,4);
    ops=hex(instr);
    disas=opctab[instr][0];
    adm=opctab[instr][1];
    step=steptab[adm];
    if (step>1) {
        op1=hex(u8(pc+1));
        if (step>2) op2=hex(u8(pc+2));
    }

    // format and output to listing
    switch (adm) {
        case 'imm' :
            ops+=' '+op1+'   ';
            disas+=' #$'+op1;
            break;
        case 'zpg' :
            ops+=' '+op1+'   ';
            disas+=' $'+op1;
            break;
        case 'acc' :
            ops+='      ';
            disas+=' A';
            break;
        case 'abs' :
            ops+=' '+op1+' '+op2;
            disas+=' $'+op2+op1;
            break;
        case 'zpx' :
            ops+=' '+op1+'   ';
            disas+=' $'+op1+',X';
            break;
        case 'zpy' :
            ops+=' '+op1+'   ';
            disas+=' $'+op1+',Y';
            break;
        case 'abx' :
            ops+=' '+op1+' '+op2;
            disas+=' $'+op2+op1+',X';
            break;
        case 'aby' :
            ops+=' '+op1+' '+op2;
            disas+=' $'+op2+op1+',Y';
            break;
        case 'iny' :
            ops+=' '+op1+'   ';
            disas+=' ($'+op1+'),Y';
            break;
        case 'inx' :
            ops+=' '+op1+'   ';
            disas+=' ($'+op1+',X)';
            break;
        case 'rel' :
            var opv=u8(pc+1);
            var targ=pc+2;
            if (opv&128) {
                targ-=(opv^255)+1;
            }
            else {
                targ +=opv;
            }
            targ&=0xffff;
            ops+=' '+op1+'   ';
            disas+=' $'+hex(targ,4);
            break;
        case 'ind' :
            ops+=' '+op1+' '+op2;
            disas+=' ($'+op2+op1+')';
            break;
        default :
            ops+='      ';
    }

    // add symbols
    switch (adm) {
        case 'zpg' :
        case 'zpx' :
        case 'zpy' :
        case 'inx' :
        case 'iny' :
            symbol = _syms_zp[op1];
            break;

        case 'abs' :
        case 'abx' :
        case 'aby' :
        case 'ind' :
            if (op2 == '00')
                symbol = _syms_zp[op1];
            else
                symbol = _syms_[op2+op1];
            break;
    }        
    if (ops=='')
        ops='        ';

    // mark validty, enrty and exit points
    // 1 = valid
    // 8 = end of block
    // 0x80 = start of block
    var valid = instr && disas != '???';
    if (valid) {
        for (var i = 0; i < step; i++)
            flags[i+pc] |= 1;    // valid code
        var a = ram[pc+1] + (ram[pc+2] << 8);
        switch (instr) {
            case 0x20: flags[a] |= 0x80; break; // jsr
            case 0x4C: flags[a] |= 0x80; flags[pc] |= 0x48; break; // jmp
            case 0x40: flags[pc] |= 0x28; break; // rti
            case 0x60: flags[pc] |= 0x18; break; // rts
        }
        if (adm == 'rel')
            flags[targ] |= 0x80;
    }

    asm.push({pc:pc,step:step,valid:valid,
        s:addr+'   '+ops+'   '+disas + (symbol ? " ; " + symbol[0] + " <i>" +  symbol[1] + "</i>": "")});
    return (pc+step);
}

//  First disassembly pass
function disassemble(addr,data,i,len,ram,flags)
{
    var asm = [];
    for (var j = 0; j < len; j++)
        ram[addr+j] = data[i+j];
    var pc = addr;
    while (pc < (addr+len))
        pc = disassembleStep(pc,ram,asm,flags);
    return asm;
}

// Two pass: disassembly then basic blocks
function disassemble2(asm,str,ram,flags)
{
    var start = 0xFFFF;
    var end = 0;
    asm.forEach(a => {
        a.flags = flags[a.pc];
        start = Math.min(start,a.pc);
        end = Math.max(end,a.pc,a.step);
        //a.s = hex(a.flags) + ":" + a.s;
    });

    function separator()
    {
        if (str[str.length-1] == "")
            return;
        str.push("");
    }

    function end_of_lines(lines)
    {
        return lines[lines.length-1].pc + lines[lines.length-1].step;
    }

    function runny(lines)
    {
        var start = lines[0].pc;
        var end = end_of_lines(lines);
        if ((end-start) < 2)
            return;
        for (var i = start+1; i < end; i++)
            if (ram[start] != ram[i])
                return false;
        return true;    // All data is the same value
    }

    function as_data(blocks)
    {
        var from = blocks[0].lines[0].pc;
        var to = end_of_lines(blocks[blocks.length-1].lines);

        var key = hex(from,4);
        str.push(`; Data ${key} to ${hex(to-1,4)} (${to-from} bytes)<em class='showcode' onclick='toggle("#_${key}")'>Show As Code</em>`);
        //  stick all the code in too
        str.push(`<div id='_${key}' style='color:#F00;display:none'>`);
        blocks.forEach(block => block.lines.forEach(line => str.push(line.s)));
        str.push("</div>");

        while (from < to) {
            var mx = 16 - (from & 0xF);
            var n = Math.min(mx,to-from);
            str.push(hex_line(from,ram,from,n,4));
            from += n;
        }
        separator();
    }

    // slice into blocks, mark those
    var blocks = [];
    var block = {lines:[],errs:0};
    function flush_block()
    {
        if (block.lines.length)
            blocks.push(block);
        block = {lines:[],errs:0};
    }
    asm.forEach(a => {
        if (a.flags & 0x80)
            flush_block();
        block.lines.push(a);
        if (!a.valid)
            block.errs++;
        if ((a.flags & 0x08) && block.errs == 0)
            flush_block();
    });
    flush_block();

    // determine if each block is ASM or DATA
    var first_code = true;
    separator();
    var data = [];
    blocks.forEach(block => {
        if (block.errs || runny(block.lines)) {
            data.push(block);           // start of data
        } else {
            if (data.length) {
                as_data(data);    // end of data
                data = [];
            }
            if (first_code) {
                str.push("; Disassembly of " + hex(start,4) + " to " + hex(end-1,4));
                first_code = false;
            }
            block.lines.forEach(a => str.push(a.s));
        }
        separator();
    });
    if (data.length)
        as_data(data);
    separator();
}

// eof

//===================================================================================================
//===================================================================================================

function le16(a,i)
{
	return a[i] | ((a[i+1]) << 8);
}

function le24(a,i)
{
    return a[i] | ((a[i+1]) << 8) | ((a[i+2]) << 16);
}

function le32(a,i)
{
    return a[i] | ((a[i+1]) << 8) | ((a[i+2]) << 16) | ((a[i+3]) << 24);
}

function is_zero(d,i,len)
{
    while (len--)
        if (d[i++])
            return false;
    return true;
}

function toAscii(a,i,len)
{
	var s = '';
	while (len--)
		s += String.fromCharCode(a[i++]);
	return s;
}

function err(e)
{
	_m("#err","#toc",{err:e});
}

function ataritext(a)
{
	var s = '';
    var lst = [];
	for (var i = 0; i < a.length; i++) {
		if (a[i] == 0x9B) {
            lst.push(s);
            s = '';
		} else
			s += String.fromCharCode(a[i]);
	}
    if (s.length)
        lst.push(s);
	return lst;
}

function parse_failed(f)
{
    return [`Can't parse ${f.name} as a ${f.ext} file`]; //'
}

function show_m65(f)
{
    var asm = mac65(f.data,0,f.data.length);
    // expand tabs?
    show_ataritext(f,asm ? asm : parse_failed(f));
}

function show_bas(f)
{
    var t = ataribasic(f.data,0,f.data.length);
    show_ataritext(f,t ? t.listing: parse_failed(f));
}

function show_txt(f)
{
    var t = ataritext(f.data,0,f.data.length);
    show_ataritext(f,t);
}

// 160*192 2 bit + [4 byte palette]
function show_img(f)
{
    render_file(f);
    var c = _q("#show");
    var aspect = render_image(c,f);
    resize_parent(c,aspect[0],aspect[1]);
}

// https://github.com/TheRobotFactory/EightBit-Atari-Fonts
function show_fnt(f)
{
    var pal = _reload_palette ? [0,5,10,15] : _palette.slice();
    var multicolor = _checks['multicolor'];

    function fnt(n,len) {
        var space = (n & 0x80) ? String.fromCharCode(128+32) : ' ';
        var s = space;
        for (var i = 0; i < len; i++)
            s += String.fromCharCode(n+i);
        return s + space;
    }
    var inverted = '';
    for (var i = 0; i < 34; i++)
        inverted += String.fromCharCode(32+128);

    var t = [];
    t.push("");
    t.push(fnt(32,32)); t.push("");
    t.push(fnt(64,32)); t.push("");
    t.push(fnt(0,32)); t.push("");
    t.push(fnt(96,32)); t.push("");
    t.push(inverted);
    t.push(fnt(32+128,32)); t.push(inverted);
    t.push(fnt(64+128,32)); t.push(inverted);
    t.push(fnt(0+128,32)); t.push(inverted);
    t.push(fnt(96+128,32)); t.push(inverted);
    var s = [
        "",
        "YOU ARE IN A MAZE OF TWISTY",
        "LITTLE PASSAGES, ALL ALIKE.",
        "",
        " - Crowther & Woods",
        "",
        "",
        "Never argue with an idiot.",
        "They will drag you down to their",
        "level and beat you with",
        "experience.",
        "",
        " - Mark Twain",
        "",
        "",
        "Nobody ever figures out what",
        "life is all about, and it doesn't",
        "matter. Explore the world. Nearly",
        "everything is really interesting",
        "if you go into it deeply enough.",
        "",
        " - Richard P. Feynman",
        "",
    ];
    s.forEach(line => t.push(' ' + line));
    t.push("");
    show_font(f,t,f.data,multicolor?_palette:null);
}

var _exts = {
    "atr": {name:"ATR Disk Image", is_disk:true},
    "atx": {name:"ATX Disk Image", is_disk:true},
    "pro": {name:"PRO Disk Image", is_disk:true},
    "xfd": {name:"XFD Disk Image", is_disk:true},
    "dsk": {name:"Raw Sectors", is_disk:true},
    "dat": {name:"Raw Data"},
    "arc": {name:"ARC Archive"},

    "--0": {name:"Languages"},
    "bas": {name:"Atari Basic/Turbo Basic XL", is_txt:true },
    "lst": {name:"Atari Basic Listing", is_txt:true },
    "asm": {name:"Assembly Listing", is_txt:true },
    "m65": {name:"MAC/65 Assembly Listing", is_txt:true },
    "lis": {name:"Listing", is_txt:true },
    "doc": {name:"Document", is_txt:true },
    "ata": {name:"ATASCII Text File", is_txt:true },
    "txt": {name:"Text File", is_txt:true },
    "bat": {name:"Batch File", is_txt:true },
    "man": {name:"Manual", is_txt:true },

    "--1": {name:"Graphics"},
    "fnt": {name:"Font File", is_txt:true, font_set:true },
    //"set": {name:"Font File", is_txt:true font_set:true },

    "gr7": {name:"Graphics 7 Image", is_img:true },
    "gr8": {name:"Graphics 8 Image", is_img:true },
    "gr9": {name:"Graphics 9 Image", is_img:true },
    "g10": {name:"Graphics 10 Image", is_img:true },

    "mic": {name:"Micropainter Image", is_img:true },
    "mcp": {name:"McPainter/Paradox Image", is_img:true },
    "apc": {name:"APAC 256 Color Image", is_img:true },
    "plm": {name:"Plasma 256 Color Image", is_img:true },
    "pzm": {name:"Pryzm Artist Image", is_img:true },
    "ilc": {name:"Digi Paint Image", is_img:true },
    "inp": {name:"InterPainter Image", is_img:true },
    "cin": {name:"Champions' Interlace", is_img:true },
    "pic": {name:"Koala MicroIllustrator", is_img:true },
    "raw": {name:"XL-Paint MAX Image", is_img:true },
    "scr": {name:"Atari Graphics Works Image", is_img:true },
    "ist": {name:"Interlace Studio Image", is_img:true },
    "rip": {name:"Rocky Interlace Picture", is_img:true },
    "hip": {name:"Hard Interlace Picture", is_img:true },
    "tip": {name:"Taquart Interlace Picture", is_img:true },

    "--2": {name:"Executables"},
    "sys": {name:"System", is_code:true },
    "xex": {name:"Load and Go Executable", is_code:true, header:true },
    "exe": {name:"Load and Go Executable (exe)", is_code:true, header:true },
    "com": {name:"Load and Go Executable (com)", is_code:true, header:true },
    "rom": {name:"ROM Dump File", is_code:true },
    "car": {name:"Cartridge File", is_code:true },
    "obj": {name:"Object Code", is_code:true },
};

// guss the file type
function get_ext(name,a,img)
{
    var i = name.lastIndexOf(".");
    if (i != -1) {
        var ext = name.substr(i+1).toLowerCase();
        if (_exts[ext])
            return ext;
    }

    if (img) {
        return img.width == 320 ? "gr8" : "gr7";
    }

    var sig = le16(a,0);
    if (sig == 0x296)
        return "atr";

    if (ATX.is_atx(a))
        return "atx";

    if (PRO.is_pro(a))
        return "pro";

    if (XFD.is_xfd(a))
        return "xfd";

    if (sig == 0xFFFF && (le16(a,2) < le16(a,4)))
        return "xex";

    if (sig == 0x80FF && le16(a,2) == 0xC7C9)
        return "pic";

    if (sig == 0x4952)
        return "rip";

    if (sig == 0xFEFE)
        return "m65";

    if (sig == 0x081A || sig == 0x041A)
        return "arc";

    try {
        if (ataribasic(a,0,a.length))
            return "bas";
    }
    catch (err) {
        console.log(err);   // guess it wasn't basic
    }

    var s='';
    for (var i = 0; i < a.length; i++)
        s += String.fromCharCode(a[i]);
    if ((s.indexOf("REM") != -1) || (s.indexOf("GOTO") != -1) || (s.indexOf("THEN") != -1))
        return "lst";

    return "dat";
}

var _id = 1;
var _container_id = 1;
var _containers = [];
function get_file(id)
{
    var f;
    _containers.forEach(c => c.files.forEach(i => { if(i.id == id) f = i}));
    return f;
}

var _shown;
function save(as_lst)
{
    var f = _shown;
    if (as_lst)
    {
        var data = get_ataritext();
        var n = f.name;
        if (n.substr(n.length-4).toLowerCase() == ".bas")
            n = n.substr(0,n.length-4);     // trim ".BAS"
        save_bytes(n+".LST",data);
    } else if (f.packed_img) {
        if (f.rgb)
            save_bytes(f.name+".rgb",f.rgb);
        else
            save_bytes(f.name+"."+f.ext,f.packed_img);
    } else
        save_bytes(f.name,f.data);
}

//===================================================================================================
//===================================================================================================
// xex/obj disassembly 

function get_xex_segs(a,i,len)
{
    if (le16(a,i) != 0xFFFF)
        return null;
    var e = i + len;
    var segs = [];
    while (i < e) {
        while (le16(a,i) == 0xFFFF)
            i += 2;
        var start = le16(a,i);
        var end = le16(a,i+2);
        i += 4;
        var slen = end+1 - start;
        if ((slen < 0) || (i + slen > e))
            return null;
        var seg = {start:start,end:end,offset:i,len:slen};
        segs.push(seg);
        i += slen;
    }
    return segs;
}

function xex_dump(name,a,i,len,expect_header,org,entry)
{
    if (name == "DOS.SYS")
        org = 0x07CB;   // http://data.atariwiki.org/DOC/Inside_Atari_DOS_GBXL.pdf

    var flags = new Uint8Array(0x10000);
    var ram = new Uint8Array(0x10000);
    var entry_points = [];
    if (entry >= 0xFFFF)
        entry = 0;
    if (org >= 0xFFFF)
        org = 0;
    if (entry)
        entry_points.push(entry);

    var segs = get_xex_segs(a,i,len);
    var header = segs && segs.length;   //

    var lines = [];
    if (!header)
    {
        var sig = le32(a,i);
        if (sig == 0x54524143) // 'CART'
        {
            i += 16;        // Cart file
            len -= 16;
        }
        var rom_entry;
        var rom_init;
        if (len == 0x2000 || len == 0x4000) {
            rom_entry = le16(a,i+len-6);
            rom_init = le16(a,i+len-2);
            if (len == 0x4000)
                org = 0x8000;          // CART A+B
            else
                org =0xA000;           // CART B
            entry_points.push(rom_entry);
            entry_points.push(rom_init); 
        }
        org = org || 0x700;

        lines.push("; file " + name + " is " + len + " bytes");
        if (rom_entry)
            lines.push("; ROM at " + hex(org,4) + " init:" + hex(rom_init,4) + " entry: " + hex(rom_entry,4));
        
        if (entry != org)
            entry_points.unshift(org);
        for (var j = 0; j < entry_points.length-1; j++)
            entry_points[j] = 0x80;

        var asms = [];
        asms.push(disassemble(org,a,i,len,ram,flags));
        asms.forEach(asm => disassemble2(asm,lines,ram,flags));
    } else {
        lines.push("; file " + name + " is " + len + " bytes");
        var s;

        // walk segments, collect entry points
        // draw them all at head, repeat them in body

        segs.forEach(seg => {
            s = "; code segment " + seg.len + " bytes at " + hex(seg.start,4) + ":" +  hex(seg.end,4);

            // note initialization and run addresses
            switch (seg.start) {
                case 0x2E0:
                    flags[seg.run = le16(a,seg.offset)] = 0x80;
                    if (seg.len == 4) {
                        flags[seg.initialize = le16(a,seg.offset+2)] = 0x80;
                        seg.note = " -> initialize at " + hex(seg.initialize,4) + ", run at " + hex(seg.run,4);
                    } else
                        seg.note = " -> run at " + hex(seg.run,4);
                    break;
                case 0x2E2:
                    flags[seg.initialize = le16(a,seg.offset)] = 0x80;
                    seg.note = " -> initialize at " + hex(seg.initialize,4);
                    break;
            }
            if (seg.note)
                s += seg.note;

            lines.push(s);
        });
        lines.push("");

        // Do the disassembly
        var asms = {};
        segs.forEach(seg => {
            if (!seg.note)
                asms[seg.offset] = disassemble(seg.start,a,seg.offset,seg.end+1 - seg.start,ram,flags);  // disassemble segment
        });

        // Completete the disassembly
        segs.forEach(seg => {
            lines.push("; ===================================================");
            s = "; code segment " + seg.len + " bytes at " + hex(seg.start,4) + ":" +  hex(seg.end,4);
            if (seg.note)
                s += seg.note;
            lines.push(s);
            lines.push('');
            if (asms[seg.offset])
                disassemble2(asms[seg.offset],lines,ram,flags);
        });
    }
    return lines.join("\n");
}

class PRO {
    static
    is_pro(d)
    {
        var s = toAscii(d,2,2);
        return s == "P2" || s == "P3";
    }

    static
    to_atr(d) {
        var sector_total = (d[0] << 8) | d[1];
        var sector_count = (d[6] << 8) | d[7];
        if (sector_count == 0)
            sector_count = 720; // p2?
        var sector_size = 128;
        var size = sector_count*sector_size;

        var atr = new Uint8Array(16+size);
        atr[0] = 0x96;
        atr[1] = 0x02;
        atr[2] = (size >> 4) & 0xFF;
        atr[3] = (size >> 4) >> 8;
        atr[4] = sector_size & 0xFF;
        atr[5] = sector_size >> 8;
        atr[6] = (size >> 4) >> 16;
        var dst = 16;
        for (var i = 0; i < sector_count; i++) {
            var src = 16+12+(12+sector_size)*i;
            var n = sector_size;
            while (n--)
                atr[dst++] = d[src++];
        }
        return atr;
    }
}

class XFD {
    static
    is_xfd(d)
    {
        //(pvbestinfoo mod) no rule for data in XFD image, since it's just an Atari raw image disk. Hence to be an XFD, image size shoud only be equal a disk size.
        //note : 256*720 stands for buggy image that considers the 3 first sectors may be 256 bytes on double density disk
	//https://forums.atariage.com/topic/123109-atr-format-reference/
        //https://forums.atariage.com/topic/293817-first-3-disk-sectors-always-128-bytes/
        if ((d.length == 128 * 720) || (d.length == 128 * 3 + 256 * 717) || (d.length == 128 * 1040) || (d.length == 256 * 720))
            return true;
    }

    static
    to_atr(d)   // append header to raw atrs
    {
        var sector_total = 720; // raw image was 702 sectors... typo of 720?
        var sector_size = 128;

        if (d.length == 1040*128)
            sector_total = 1040;
        if (d.length == (128*3 + (1040-3)*256)) {
            sector_total = 1040;
            sector_size = 256;
        }

        var size = sector_total*sector_size;
        var atr = new Uint8Array(16+size);
        atr[0] = 0x96;
        atr[1] = 0x02;
        atr[2] = (size >> 4) & 0xFF;
        atr[3] = (size >> 4) >> 8;
        atr[4] = sector_size & 0xFF;
        atr[5] = sector_size >> 8;
        atr[6] = (size >> 4) >> 16;
        atr.set(d, 16);
        return atr;
    }
}

class ATX {
    static
    is_atx(d)
    {
        return toAscii(d,0,4) == "AT8X";
    }

    static
    to_atr(d) {
        if (!ATX.is_atx(d))
            return null;
        var atx = new ATX(d);
        var atr = new Uint8Array(16+atx.size);
        var sector_count = 720;

        atr[0] = 0x96; // (pvbestinfoo) $0296 = checksum of 'NICKATARI' string
        atr[1] = 0x02;
        atr[2] = (atx.size >> 4) & 0xFF;
        atr[3] = (atx.size >> 4) >> 8;
        atr[4] = atx.sector_size & 0xFF;
        atr[5] = atx.sector_size >> 8;
        atr[6] = (atx.size >> 4) >> 16;
        var dst = 16;
        for (var i = 0; i < sector_count; i++)
            dst = atx.readsector(i,atr,dst);
        return atr;
    }

    constructor(d)
    {
        this.d = d;
        this.sector_size = 128;
        this.tracks = [];
        var t = le32(d,28);
        while (t > 0 && t < d.length) {
            var track = {toff:[]};
            track.offset = t;
            track.size = le32(d,t);
            track.type = le16(d,t+4);
            track.tracknum = d[t+8];
            track.sectorcount = le16(d,t+10);
            track.headersize = le32(d,t+20);
            track.sectorlistsize = le32(d,t+32) - 8;
            for (var i = 0; i < 16; i++)
                track.toff[i] = 0;
            var sl = t+40;
            for (var i = 0; i < track.sectorlistsize; i += 8) {
                var dat = le32(d,sl+i+4);
                if (dat && d[sl+i])
                    track.toff[d[sl+i]-1] = dat;
            }
            this.tracks.push(track);
            t += track.size;
        }
        this.size = 720*this.sector_size;
    }

    readsector(n,dst,dsti)
    {
        var d = this.d;
        var track = n/18 | 0;
        var ss = this.sector_size;
        this.tracks.forEach(t => {
            if (t.tracknum == track) {
                var dat = t.toff[n % 18];
                if (dat) {
                    for (var i = 0; i < ss; i++)
                        dst[dsti+i] = d[t.offset + dat++];
                }
            }
        });
        return dsti + this.sector_size;
    }
}

class SpartaDOS {
    constructor(atr) {
        var d = atr.d;
        this.atr = atr;
        this.boot = {
            sector_map: le16(d,16+9),       // Sector, where is the first Sector map of the main directory.
            sector_count: le16(d,16+11),    // Number of every sectors on the disk
            free_sectors: le16(d,16+13),    // Number of free sectors
            bitmaps: d[16+15],              // Number of Bitmaps
            first_bitmap: le16(d,16+16),    // Sector used for the first Bitmap.
            sector_file: le16(d,16+18),     // The first sector, where may be allocated a data sector for a file
            sector_dir: le16(d,16+20),      // The first sector, where may be allocated a data sector for a directory
            volume_name: toAscii(d,16+22,8).trim(),
            tracks: d[16+30],               // Number of tracks; when the bit D7 is set, then the drive is double
            sector_size: d[16+31] ? 128:256,// Size of sectors (128 or 0 == 256)
            version: d[16+32],              // $11 - created by SpartaDOS 1.x
            sequential: d[16+38],           // This number is incremented every time you're making any changes on the disk
            random: d[16+39],               // Random number of the disk. This number is created while formatting the disk.
            boot_sector: le16(d,16+40)      // Sector, where is the first Sector map of file specified for booting
        }
        this.file_info = {};
    }

    // first entry in directory is information about the directory itself
    // start == parent;
    get_dir(sector_map)
    {
        sector_map = sector_map || this.boot.sector_map;
        var dir = this.read_file(sector_map);
        var files = [];
        var dir_info;
        var sector_size = this.boot.sector_size;
        for (var i = 0; i < dir.length && dir[i]; i += 23)
        {
            if (i == 0) {
                dir_info = {
                    flags:dir[i],
                    parent:le16(dir,i+1),
                    len:le24(dir,i+3),
                    name83:toAscii(dir,i+6,8),
                    name:toAscii(dir,i+6,8).trim()
                }
            } else {
                /*
                0x01 // protected
                0x04 // in use
                0x10 // Erased
                0x20 // subdirectory
                */
                var flags = (dir[i] & 0x04) ? 0 : 0x42;
                if (dir[i] & 1)
                    flags |= 0x20;  // locked
                var f = {
                    flags:flags,
                    valid:true,
                    start:le16(dir,i+1),
                    len:le24(dir,i+3),
                    name83:toAscii(dir,i+6,11),
                    name:toAscii(dir,i+6,8).trim(),
                    date:le24(dir,i+17),
                    time:le24(dir,i+20),
                    is_dir:dir[i] & 0x20
                }
                var ext = toAscii(dir,i+14,3).trim();
                if (ext.length)
                    f.name += '.' + ext;

                this.file_info[f.start] = f; // we know the length

                f.sectors = [];
                var sec = this.get_sectors(f.start);
                for (var j = 0; j < sec.length; j++) {
                    f.sectors.push({
                        sector:sec[j],
                        len: Math.min(sector_size,f.len - j*sector_size),
                        offset: j
                    });
                }
                f.total = f.sectors.length;
                files.push(f);

                // recurse?
                if (f.is_dir)
                    files = files.concat(this.get_dir(f.start));
            }
        }
        return files;
    }

    // get all the sectors associated with the file
    get_sectors(sector_map)
    {
        var atr = this.atr;
        var d = atr.d;
        var sector_size = this.boot.sector_size;

        // format is next:prev:s:s:s.... 16 bit entries
        var sectors = [];
        while (sector_map) {
            var sm = atr.sector_offset(sector_map);
            for (var i = 2; i < sector_size/2; i++) {
                var s = le16(d,sm + i*2);
                if (!s)
                    break;
                sectors.push(s);
            }
            sector_map = le16(d,sm);    // next sector of sector map
        }
        return sectors;
    }

    read_file(sector_map)
    {
        var atr = this.atr;
        var file_info = this.file_info[sector_map];
        var d = atr.d;
        var dst = [];
        this.get_sectors(sector_map).forEach(s => {
            var src = atr.sector_offset(s); 
            for (var i = 0; i < this.boot.sector_size; i++)
                dst.push(d[src+i]);
        });
        if (file_info && !file_info.is_dir)
            dst.length = file_info.len;   // clip it if we know the size
        return new Uint8Array(dst);
    }
}

/*
0x01   File Opened for Output.
0x02   File Created by Dos 2.
0x10   Mydos DIR?
0x20   File Locked (appears with '*' in directory).
0x40   File In use (normal)
0x80   File Deleted
*/

// http://atari.kensclassics.org/dos.htm
// http://www.atarimax.com/jindroush.atari.org/afmtatr.html
class ATR {
    constructor(d,name) {
        if (ATX.is_atx(d))
            d = ATX.to_atr(d);
        else if (PRO.is_pro(d))
            d = PRO.to_atr(d);
        else if (XFD.is_xfd(d))
            d = XFD.to_atr(d);

        this.d = d;
        this.name = name;
        this.size = (le16(d,2) + (d[6] << 16)) << 4;
        this.sector_size = le16(d,4);
        this.sector_count = (this.size-128*3)/this.sector_size + 3;
        this.dir_sector = -1;
        if (d[16+7] == 0x80)
            this.sparta = new SpartaDOS(this);
    }

    sector_offset(n) {    // 1 based
        n--;
        if (n < 3)
            return 16 + n*0x80;     // header is 16 bytes
        return 16 + 3*0x80 + (n-3)*this.sector_size;
    }

    one_dir(n,sector) {
        sector = sector || 361;
        var d = this.d;
        var j = this.sector_offset(sector + (n >> 3)) + (n & 7)*16;
        var dir = {
            flags:d[j],
            total:le16(d,j+1),
            start:le16(d,j+3),
            name83:toAscii(d,j+5,11),
            name:toAscii(d,j+5,8).trim()
        };
        var ext = toAscii(d,j+13,3).trim();
        if (ext.length)
            dir.name += '.' + ext;

        dir.valid = (dir.flags & 0x40) != 0 && !(dir.flags & 0x8C);
        for (var i = 0; i < 11; i++)
            dir.valid = dir.valid && (d[j+5+i] != 0);
        dir.valid = dir.valid && (dir.total < this.sector_count) && (dir.start < this.sector_count);
        dir.valid = dir.valid && dir.total && dir.start > 3;

        // get all sectors associated with this entry
        if (dir.valid) {
            dir.sectors = [];
            var sector = dir.start;
            var num = -1;
            for (var k = 0; k < dir.total; k++) {
                var end = this.sector_offset(sector) + this.sector_size;
                var len = d[end-1];
                var next = ((d[end-3] & 0x03) << 8) | (d[end-2]);   // TODO: 10 bits?
                if (num == -1)
                    num = d[end-3] >> 2;
                var good_len = next == 0 ? len <= (this.sector_size-3) : len == (this.sector_size-3);
                if (next >= this.sector_count || (num != (d[end-3] >> 2)) || !good_len)
                {
                    dir.valid = false;
                    break;
                }
                dir.sectors[sector] = {sector:sector,len:len,next:next,offset:k};
                if (next == 0) {
                    if (k != dir.total-1)
                        dir.valid = false;
                    break;  // EOF?
                }
                sector = next;
            }
            if (!dir.valid)
                dir.sectors = [];
        }
        return dir;
    }

    // Search the entire disk for sneaky directory entries
    get_dir_range(from,to)
    {
        var dirs = [];
        for (var i = from; i < to; i++) {
            for (var n = 0; n < 8; n++) {
                var dir = this.one_dir(n,i);
                if (dir.valid) {
                    if (this.dir_sector == -1)
                        this.dir_sector = i;
                    dirs.push(dir);
                }
            }
        }
        return dirs;
    }

    // Search the entire disk for sneaky directory entries
    get_dir()
    {
        if (this.sparta)
            return this.sparta.get_dir();

        var dirs = this.get_dir_range(361,369);
        if (dirs.length < 1 || (this.dir_sector != 361))
            dirs = this.get_dir_range(4,this.sector_count); // try the whole disk
        if (this.dir_sector == -1)
            this.dir_sector = 361;  // didn't find one, use default
        this.scan_files(dirs);      // try and find files that don't have a real directory entry
        return dirs;
    }

    scan_files(dirs)
    {
        var d = this.d;
        var sectors = [];

        var used = [];
        dirs.forEach(dir => dir.sectors.forEach(s => used[s] = dir));

        var files = [];
        for (var i = 4; i < this.sector_count; i++) {
            var end = this.sector_offset(i) + this.sector_size;
            var len = d[end-1];
            var next = ((d[end-3] & 0x03) << 8) | (d[end-2]);   // TODO: 10 bits
            if (len == (this.sector_size-3) || ((len <= (this.sector_size-3)) && next == 0))
                sectors[i] = {sector:i,len:len,next:next,num:d[end-3] >> 2};
        }
        sectors.forEach(s => {
            var n = sectors[s.next];
            if (n)
                n.prev = s.sector;
        });
        sectors.forEach(s => {
            if (!s.prev) {
                s.total = 0;
                s.bytes = 0;
                s.used = 0;
                s.error = 0;
                s.sectors = [];
                var n = s;
                do {
                    s.sectors.push(n);
                    if (used[n.sector])
                        s.used = used[n.sector];
                    s.bytes += n.len;
                    s.total++;
                    if (s.num != n.num)
                        s.error++;
                    if (n.next == 0)
                        break;
                    var np = sectors[n.next];
                    if ((n != s) && (!np || (np.prev != n.sector))) {
                        s.error++;
                        break;
                    }
                    n = np;
                } while(n);
                if (s.error == 0 && s.total > 1)
                    files.push(s);
            }
        });

        var _correlated = 0;
        function match(s) {
            for (var i = 0; i < dirs.length; i++)
                if (dirs[i].start == s) {
                    dirs[i].correlated = true;
                    _correlated++;
                    return dirs[i];
                }
            return null;
        }

        // now we have chains of files, recover those missing dir entries
        var i = 0;
        files.forEach(f => {
            if (!match(f.sector)) {
                var name = "FILE_" + hex(i++) + ".DAT";
                var name83 = "FILE_" + hex(i++) + " DAT";

                // Reconstruct stopmed dirs
                if (this.dir_sector == 361) {
                    var nom = this.one_dir(f.num);
                    if (nom.flags & 0x40) {
                        name83 = nom.name83;
                        name = nom.name;
                    }
                }

                if (f.used) {
                    console.log(name + " also used by " + f.used.name);
                } else {
                    var dir = {sectors:[],valid:true,start:f.sector,total:f.total,name:name,name83:name83,flags:0x42,recovered:true};
                    var offset = 0;
                    do {
                        dir.sectors[f.sector] = {sector:f.sector,len:f.len,next:f.next,offset:offset++};
                        if (f.next == 0)
                            break;
                        f = sectors[f.next];
                    } while(f);
                    dirs.push(dir);
                }
            }
        });
    }

    read(f) {
        if (this.sparta)
            return this.sparta.read_file(f.start);

        var data = [];
        var count = f.total;
        var sector = f.start;
        var d = this.d;
        f.errors = 0;
        while (count--) {
            var i = this.sector_offset(sector);
            var end = i + this.sector_size;
            var len = d[end-1];
            if (len > (this.sector_size-3))
                f.errors++;
            var next = ((d[end-3] & 0x3) << 8) | d[end-2];  // TODO: 10 bits?
            for (var k = 0; k < len; k++)
                data.push(d[i + k]);
            if (next == 0) {
                if (count)
                    f.errors++;
                break;  // EOF?
            }
            sector = next;
        }
        return new Uint8Array(data);
    }
}

//===================================================================================================
//===================================================================================================
// arc files

function dearc_3(srcd,srclen,dstlen)    // RLE - after altirra
{
    var dst = 0;
    var src = 0;
    var dstd = new Uint8Array(dstlen);

    let last = 0;
    while (dstlen) {
        let c = srcd[src++];
        if (c == 0x90) {
            if (!srclen--)
                return null;
            let d = srcd[src++];
            if (d == 0) {
                prevoutput = last;
                if (!dstlen--)
                    return null;
                dstd[dst++] = 0x90;
            } else {
                let count = d - 1;
                if (dstlen < count)
                    return null;
                dstlen -= count;
                while (count--)
                    dstd[dst++] = last;
            }
        } else {
            last = c;
            if (!dstlen--)
                return null;
            dstd[dst++] = c;
        }
    }
    return dstd;
}

function dearc_8(srcd,srclen,dstlen)    // after altirra
{
    var dst = 0;
    var src = 0;
    var n = 256;
    var last = 0;
    var byte2 = false;
    var bits = 9;
    var accum = 0;
    var accumbits = 0;
    var lastCode = 0;
    var codesRead = 0;
    var dstd = new Uint8Array(dstlen);

    var prev_link = new Int16Array(4096);
    var first_char = new Uint8Array(4096);
    var last_char = new Uint8Array(4096);
    var tmp = new Uint8Array(4096);
    for (var i=0; i<256; i++) {
        prev_link[i] = -1;
        first_char[i] = last_char[i] = i;
    }

    if (srcd[src++] != 0xC) // longest code length?
        return null;

    while(dstlen)
    {
        let code = 0;
        for (let i = 0; i < bits; ++i)
        {
            if (!accumbits) {
                if (!srclen--)
                    return null;
                accum = srcd[src++];
                accumbits = 8;
            }

            if (accum & 1)
                code += (1 << bits);

            accum >>= 1;
            --accumbits;
            code >>= 1;
        }

        ++codesRead;
        if (code > n)
            return null;

        if (code == 256)
        {
            let align = ((-codesRead & 7)*bits) >> 3;
            if (srclen < align)
                return null;
            srclen -= align;
            src += align;

            // reset code table
            n = 256;
            bits = 9;
            lastCode = 0;
            accumbits = 0;
            accum = 0;
            codesRead = 0;
            continue;
        }

        if (n < 4096) {
            first_char[n] = first_char[lastCode];
            if (code == n)
                last_char[n] = first_char[n];
            else
                last_char[n] = first_char[code];
            prev_link[n] = lastCode;

            ++n;
            if (n >= (1 << bits) && bits < 12)
                ++bits;
        }

        var tmpstart = 4096;
        for (var link = code; link >= 0; link = prev_link[link])
            tmp[--tmpstart] = last_char[link];

        while (tmpstart != 4096)
        {
            let c = tmp[tmpstart++]
            if (byte2) {
                if (c == 0) {
                    last = 0x90;
                    if (!dstlen--)
                        return null;
                    dstd[dst++] = 0x90;
                } else {
                    let count = c - 1;
                    if (dstlen < count)
                        return null;
                    dstlen -= count;
                    while(count--)
                        dstd[dst++] = last;
                }
                byte2 = false;
            } else {
                if (c == 0x90)
                    byte2 = true;
                else {
                    last = c;
                    if (!dstlen--)
                        return false;
                    dstd[dst++] = c;
                }
            }
        }
        lastCode = code;
    }
    return dstd;
}

function arc_extract(id,pos)
{
    var file = get_file(id);
    function extract(pos)
    {
        var f = file.arc[pos];
        var d = file.data.slice(pos,pos + f.compressed_size);
        switch (f.method) {
            case 3: d = dearc_3(d,f.compressed_size,f.original_size); break;
            case 8: d = dearc_8(d,f.compressed_size,f.original_size); break;
        }
        load_one(f.name,get_ext(f.name,d),d);
    }
    if (pos == -1)
        file.arc.forEach(a => extract(a.pos));
    else
        extract(pos);
    refresh_containers();
}

function show_arc(f)
{
    var d = f.data;
    var files = [];
    var txt = [];
    var sel = [];
    var i;

    var _methods = [
        "End of archive marker",
        "unpacked (obsolete) - ARC 1.0 ?",
        "unpacked - ARC 3.1",
        "packed (RLE encoding)",
        "squeezed (after packing)",
        "crunched (obsolete) - ARC 4.0",
        "crunched (after packing) (obsolete) - ARC 4.1",
        "crunched (after packing, using faster hash algorithm) - ARC 4.6",
        "crunched (after packing, using dynamic LZW variations) - ARC 5.0",
        "Squashed c/o Phil Katz (no packing) (var. on crunching)"];

    var i = 0;
    f.arc = [];
    var count = 0;
    while (i < d.length) {
        if (d[i+0] != 0x1A)
            break;
        var method = d[i+1];
        if (!method)
            break;  // end of archive is 0x1A 0x00

        var name = '';
        for (var j = 0; d[i+2+j] && j < 12; j++)
            name += String.fromCharCode(d[i+2+j]);

        var file = {
            method : method,
            name : name,
            compressed_size: le32(d,i+15),
            date: le32(d,i+19),
            crc: le16(d,i+23),
            original_size: le32(d,i+25),
            pos: i + 29
        }
        f.arc[file.pos] = file;
        sel.push(`; ${file.name} <button style="float:right" onclick='arc_extract(${f.id},${file.pos})'>Extract</button>`);
        sel.push(`; ${file.original_size} bytes (${file.compressed_size} compressed)`);
        sel.push("");

        txt.push("; " + file.name);
        txt.push("; " + _methods[method] + ", " + file.compressed_size + " -> " + file.original_size);
        txt.push("");
        txt.push(hex_dump(d,i+29,file.compressed_size,4));
        txt.push("");

        i += 29 + file.compressed_size;
        count++;
    }
    sel.unshift(`; ${f.name} archive contains ${count} files<button style="float:right" onclick='arc_extract(${f.id},-1)'>Extract All</button>\n\n`);
    sel.push("");

    render_file(f);
    _h("#show",sel.join("\n") + txt.join("\n"));
}

//===================================================================================================
//===================================================================================================
// dump atr raw data (ATR, ATX, PRO and XFD that are tagged .is_disk)

function show_atr(f,rawmode)
{
    var atr = f.atr;
    var d = atr.d;
    var txt = [];

    // just the raw sectors
    if (rawmode) {
        var n = 0;
        for (;;)
        {
            var size = n < 3 ? 128 : atr.sector_size;
            var offset = atr.sector_offset(n+1);
            if (offset >= (atr.size+16))
                break;
            var zero = is_zero(d,offset,size);
			var sect = n + 1; //(pvbestinfoo) Sector should be counted from 1 to 720 (or 1 to 1040)
	        //(pvbestinfoo) adding the display of sector hexa value and decimal value into parenthesis :
            txt.push("; Sector " + hex(sect, 3) + " (" + sect + ")" + (zero ? " (" + size + " zeros)" : ""));

            if (!zero)
                txt.push(hex_dump(d,offset,size,4));
            txt.push("");
            n++;
        }
        render_file(f);
        _h("#show",txt.join("\n"));
        return;
    }

    function pad_hex(n)
    {
        return n > 0xFF ? hex(n,4) : '  ' + hex(n);
    }
    // (pvbestinfoo) source https://www.atariarchives.org/mapping/appendix17.php : DOS 2.5 loads its boot sector at address $700
    var _br = {
        BFLG:   d[16],          // Boot flag; always equals 0.
        BRCNT:  d[17],          // Number of sectors in the disk boot;
        BLDADDR:le16(d,18),     // Boot load address; where DOS is loaded into memory;  $700
        BINTAD: le16(d,20),     // DOS initialization address;  $1540. 
        BCONT:  le16(d,23),     // skip 4C jmp
	// (pvbestinfoo) end of normal boot sector
	// (pvbestinfoo) DOS disk additional boot info :
        SABYTE: d[25],          // Maximum number of concurrently open files--usually three.
        DRVBYT: d[26],          // Drive allocation byte; one bit per drive.
        SAFBFW: d[27],
        SASA:   le16(d,28),     // Buffer allocation address for drives and files.
        DFSFLG: d[30],          // Reads zero if there is no DOS.SYS on disk, nonzero if present
        DFLINK: le16(d,31),     // Points to first sector of the DOS.SYS file.
        BLDISP: d[33],          // Number of displacement bytes to sector link bytes (last three) = 125
        DFLADDR: le16(d,34),    // Address of the FMS (D:) handler table; $7CB
        // $714 boot continues here...
    };

    function available(n)
    {
        return d[vtoc + 10 + (n >> 3)] & (0x80 >> (n & 3));
    }

    // Check validity of TOC
    var sparta = atr.sparta;
    var sc = (atr.size - 3*128)/atr.sector_size + 3;
    var vtoc = atr.sector_offset(360);
    var valid = d[vtoc] == 2;
    var total = le16(d,vtoc+1);
    var unused = le16(d,vtoc+3);
    var density;

    if (total > sc || total == 0 || unused > sc)
        valid = false;

    var vtoc2 = 0;
    if (sc <= 720) {
        density = atr.sector_size == 128 ? "Single Density" : "Double Density";
        for (var i = 101; i < 128; i++)
            valid = valid && d[vtoc+i] == 0;
    } else {
        density = "1050 Double (Enhanced) Density";
        vtoc2 = atr.sector_offset(1024);
        if (valid)
            unused += le16(d,vtoc2+122);
    }

    txt.push(`; <b>Image has ${sc} ($${sc.toString(16).toUpperCase()}) sectors of ${atr.sector_size} bytes - ` + density + "</b>"); //(pvbestinfoo) wording modification
    if (sparta) {
        // something
    } else {
        txt.push(valid ? `; ${unused} sectors free of ${total} total available` : `; VTOC is invalid`);
        txt.push("; Jump to <a id='BOOT' href='#VTOC'>VTOC</a>");
        if (vtoc2)
            txt.push("; Jump to <a id='BOOT' href='#VTOC2'>VTOC2</a>");
        txt.push("; Jump to <a href='#DIR'>Directory</a>");
    }
    txt.push("");

    // Show boot sectors, disassemble them

    txt.push(";<b> Boot sector record:</b>"); //(pvbestinfoo) wording modification
    var k = Object.keys(_br);
    var bi = '', bic = ''; //(pvbestinfoo) variables are for italic HTML element for displaying boot information for non DOS disk 
    for (var i = 0; i < (sparta ? 5 : k.length); i++) {
        txt.push("; " + bi + pad_hex(_br[k[i]]) + " " + k[i] + bic);
            //(pvbestinfoo) modifying the display of the Boot Record
            if (i == 3 && !sparta) {// (pvbestinfoo) check at the 4th value of boot record (i.e. BCONT)
                if (d[22] == 0x4C) // (pvbestinfoo) is there a JUMP $4C to BCOUNT ?
                    txt.push("; Boot execution start with a JUMP to BCONT=$" + hex(_br[k[4]],4)); // (pvbestinfoo) yes
                else { // (pvbestinfoo) no, so display the normal boot execution start address
                    txt.push("; Boot execution start at BLDADDR+6=$" + hex(_br[k[2]]+6,4));
                    bi ="<i>"; // (pvbestinfoo) and all remaining boot info are not relevant and displayed in italic
                    bic ="</i>";
                }
                txt.push("; " + bi + "<b>Additional DOS boot info:</b>" + bic); // (pvbestinfoo) DOS disk additional boot info title display
            }
    }
    if (sparta) {
        txt.push("");
        txt.push("; SpartaDOS");
        var br = sparta.boot;
        var k = Object.keys(br);
        for (var i = 0; i < k.length; i++) {
            if (k[i] == 'volume_name')
                txt.push(`;      ${k[i]} '${br[k[i]]}'`);
            else
                txt.push("; " + pad_hex(br[k[i]]) + " " + k[i]);
        }
    }
    txt.push("");

    var size = atr.sector_offset(_br.BRCNT+1);    // 0 based
    var boot = d.slice(16,size);
    var cont = _br.BCONT - _br.BLDADDR;
    cont = (cont < 0 || cont >= boot.length) ? _br.BLDADDR : _br.BCONT;
    txt.push(xex_dump("boot",boot,0,boot.length,0,_br.BLDADDR,cont));

    // Scan files/sectors
    // TODO: Broken links, deleted files
    var dirs = atr.get_dir();
    var sectors = [];
    dirs.forEach(dir => dir.sectors.forEach(s => {sectors[s.sector] = {dir:dir,sector:s}}));
    console.log(dirs);
    console.log(sectors);

    var n = 0;
    for (;;)
    {
        var size = n < 3 ? 128 : atr.sector_size;
        var offset = atr.sector_offset(n+1);
        if (offset >= (atr.size+16))
            break;
        var zero = is_zero(d,offset,size);

        switch (++n) {
            case 360: txt.push("; <span id='VTOC'>Volume Table of Contents <a href='#BOOT'>(back)</a></span>"); break;
            case atr.dir_sector: txt.push("; <span id='DIR'>Directory <a href='#BOOT'>(back)</a></span>"); break;
            case 1024: txt.push("; <span id='VTOC2'>Volume Table of Contents 2<a href='#BOOT'>(back)</a></span>"); break;
        }

        var s = sectors[n];
        var sstr = "";
		//(pvbestinfoo) modify the dislay of the sector title with corresponding hex value
		if (s) {
                var sect = s.sector.offset + 1; //(pvbestinfoo) sector count starts at 1
                sstr = " [" + s.dir.name + " - Sector " + (s.sector.offset + 1) + " of " + s.dir.total;
                sstr += " ($" + sect.toString(16).toUpperCase() + "/$" + s.dir.total.toString(16).toUpperCase() + ")]";
            }
        txt.push("; Sector $" + hex(n, 3) + " (" + n + ")" + (zero ? " (" + size + " zeros)" : "") + sstr);

        if (!zero)
            txt.push(hex_dump(d,offset,size,4));
        txt.push("");

        if (n == _br.BRCNT) {
            txt.push("; ===================================================");
            txt.push("; End of boot sectors");
            txt.push("");
        }
    }

    render_file(f);
    _h("#show",txt.join("\n"));
}

function show(id)
{
    try {
        var f = get_file(id);
        if (f.data.length == 0)
            return;

        _shown = f;
        if (f.ext == "bas") {
            show_bas(f);
            return;
        }

        if (f.ext == "m65") {
            show_m65(f);
            return;
        }

        if (f.ext == "fnt" || f.ext == "set") {
            show_fnt(f);
            return;
        }

        if (f.ext == "arc") {
            show_arc(f);
            return;
        }

        var e = _exts[f.ext];
        if (e && e.is_disk) {
            show_atr(f,f.ext == "dsk");
            return;
        }
        if (e && e.is_img) {
            show_img(f);
            return;
        }

        if (e && e.is_txt) {
            show_txt(f);
            return;
        }

        render_file(f);
        if (e && e.is_code) {
            _h("#show",xex_dump(f.name,f.data,0,f.data.length,e.header));
            return;
        }
        _h("#show",hex_dump(f.data,0,f.data.length));
    }
    catch (err) {
        console.log(err);
        show_as("dat");
    }
}

function show_as(e)
{
    if (_shown) {
        if (!_shown.original_ext)
            _shown.original_ext = _shown.ext;
        _shown.ext = e;
        refresh();    // select one
    }
}

function toggle_hex()
{
    if (!_shown) return;
    if (_shown.ext == "dat")
        show_as(_shown.original_ext);
    else
        show_as("dat");
}

function refresh()
{
    show(_shown.id);
}

function close_container(id)
{
    for (var i = 0; i < _containers.length; i++) {
        if (_containers[i].id == id) {
            _containers.splice(i,1);
            break;
        }
    }
    render_state(_containers);
}

function load_one(name,ext,a,img)
{
    var f = {name:name,ext:ext,data:a,id:_id++,total:(a.length+127)>>7,img:img};
    var i = name.lastIndexOf(".");
    var ext83 = ext;
    if (i != -1) {
        ext83 = name.substr(i+1);
        name = name.substr(0,i);
    }
    f.name83 = name.substr(0,8);
    while (f.name83.length < 8)
        f.name83 += ' ';
    f.name83 += ext83.toUpperCase().substr(0,3);
    _containers.unshift({name:f.name,ext:ext,data:a,files:[f],id:_container_id++});         // single file
    return f;
}

function load_data(name,a,img)
{
    var ext = get_ext(name,a,img);
    var e = _exts[ext];
	if (!e || !e.is_disk) {        // not an atr file
        return load_one(name,ext,a,img);
	} else {
        var atr = new ATR(a,name);
        var dir = atr.get_dir();
        var files = [];
        dir.forEach(f => {
            if (f.valid) {
                var file = {name:f.name,name83:f.name83,id:_id++,total:f.total,flags:f.flags,recovered:f.recovered,is_dir:f.is_dir};
                file.data = atr.read(f);
                if (f.errors) {
                    console.log("Error reading file " + f.name);
                    console.log(f);
                }
                file.ext = get_ext(file.name,file.data);
                files.push(file);
            }
        });
        if (files.length)
            files.push({name83:"",name:name,ext:"",data:[],id:_id++});  // spacer
        files.push({name83:atr.sector_count + " sectors",name:name,ext:ext,data:a,id:_id++,atr:atr});
        _containers.unshift({name:name,length:a.length,data:a,ext:ext,files:files,id:_container_id++});
    }
}

//===================================================================================================
//===================================================================================================
// https://www.atarimagazines.com/software/software.html

var _images = [];

function flush_images()
{
    _images.forEach(f => {
        var b = '';
        for (var i = 0; i < f.data.length; i++)
            b += String.fromCharCode(f.data[i]);
        var url = `data:${f.file.type};base64,${btoa(b)}`;

        var img = document.createElement('img');
        img.src = url;
        img.hidden = true;
        img.onload = (evt) => {
            load_data(f.file.name,f.data,img).edit_img = 1;
            refresh_containers();
            document.body.removeChild(img);
        }
        document.body.appendChild(img);
    });
    _images = [];
}

function refresh_containers()
{
    render_state(_containers);
    if (_containers.length)
        show(_containers[0].files[0].id);    // select on
}

// #153382 - BG 0x94

function open()
{
    _q("#fe").click();
}

function load()
{
    drop_init(_q("#toc"),
        (file,ab) => {
            if (file.type.indexOf("image")!= -1)
                _images.push({file:file,data:new Uint8Array(ab)});
            else
                load_data(file.name,new Uint8Array(ab))
        },
        () => {
            flush_images();
            refresh_containers();
        }
    );
    _fcanvas = get_font(_font);

    document.body.onkeyup = function (e) {
    }

    document.onselectionchange = selection_change;

    document.body.onkeydown = function (e) {
        if (e.ctrlKey && e.shiftKey) {
            switch (e.key) {
                case 'o':
                case 'O':
                    open();
                    break;  // open a file....
                case 'h':
                case 'H':
                    toggle_hex();
                    break;  // toggle hex display
                case 'k':
                case 'K':
                    toggle_kb();
                    break;  // toggle keyboard
            }
        }
    };
    render_state(_containers);
}

function toggle(eid)
{
    var e = _q(eid);
    e.style.display = e.style.display == "none" ? "block" : "none";
}

function ext_option(f)
{
    var s = `<div style='display:inline-block'><select onchange="show_as(this.value)">`;
    Object.keys(_exts).forEach(ext => s += `<option ${ext[0] == '-' ? "disabled":""} value='${ext}' ${ext == f.ext ? 'selected':''}>${_exts[ext].name}</option>`);
    s += `</select></div>`;
    return s;
}

function finfo(f)
{
    var t = _exts[f.ext] ? _exts[f.ext].name : "'" + f.ext + "' file";
    return `<b>${f.name}</b><div style="font-size:small">${t} (${f.data.length} bytes)</div>`;
}

function redraw_palette()
{
    _h(".palette",palette(_palette));
}

function pick_click(c,i)
{
    _palette[c] = i;
    _reload_palette = 0;    // make sure our changes take
    refresh();
    redraw_palette();
    _reload_palette = 1;
}

var atari2css = (i) => '#'+hex(atari_palette_rgb[i],6);
function palette(colors)
{
    function atari256(c) {
        var s = [];
        for (var i = 0; i < 256; i++)
            s.push(`<div class='acolor' title='${hex(i)}' onclick='pick_click(${c},${i})' style='background:${atari2css(i)}'></div>`);
        return s.join("");
    }
    var s = [];
    for (var c = 0; c < colors.length; c++) {
        s.push(
            `<div class='dropdown'>
                <div class='acolor' title='${hex(colors[c])}' style='background:${atari2css(colors[c])}'>
                    <div class='dropdown-content'>${atari256(c)}</div>
                </div>
            </div>`
        );
    }
    return s.join("");
}

function pick_mono(cr)
{
    _mono_cr = cr;
    _radios["scheme"].value = 0;    // mono
    refresh();
}

function refresh_image_controls(f)
{
    function monochrome()
    {
        var s = '';
        for (var i = 0; i < 16; i++) {
            var c = (i << 4) | 8;
            s += `<div class='acolor' title='${hex(c)}' onclick='pick_mono(${c>>4})' style='background:${atari2css(c)}'></div>`;
        }
        return s;
    }
    _h("#image_controls",`
    <div class='exts' style="padding:8px">
        <div><b>dither</b><span class='radio'>${radio_init('dither',['atkinson','floyd-steinberg','noise','ordered','none'])}</span><div><br/>
        <div><b>scheme</b><span class='radio'>${radio_init('scheme',['monochrome','r:g','random','kmeans','octree','median'])}</span><div><br/>
        <div><b>monochrome</b><span style='padding-left:12px'>${monochrome()}<span><div><br/>
        <div><b>distance</b><span class='radio'>${radio_init('distance',['rgb','yiq','y'])}</span><div><br/>
    </div>`);
}

function render_state(m)
{
    var h;
    if (m.length == 0) {
        h = `<div style="text-align:center;color:#AAA"><h2>Drag Files Here</h2><h2>or</h2></div>`;
        _h("#tabs","");
        _shown = null;
    } else
        h = m.map(container => 
        `<div>
            <span class='close-icon' onclick="close_container(${container.id})"></span>
            <div class='infof'>${finfo(container)}</div>
            <ul id="menu">
            ${container.files.map(file => 
                `<li onclick="show(${file.id})">
                    <div><canvas id="canvas${file.id}"></canvas></div>
                </li>`
            ).join("")}
            </ul>
        </div>`
    ).join("");
    _h("#menu_container",h);

    function info(f)
    {
        var s = '';
        if (f.total) {
            s = '' + f.total;
            while (s.length < 3)
                s = '0' + s;
        }
        while (s.length < 4)
            s = ' ' + s;
        var n = f.name83;
        while (n.length < 12)
            n += ' ';
        var locked = f.flags & 0x20 ? "*" : " ";
        return "  " + locked + " " + n + s + "  ";
    }

    m.forEach(container => {
        container.files.forEach(file => draw_line(`#canvas${file.id}`,info(file),file.recovered,file.is_dir));
    });

    // show supported file types
    if (m.length == 0) {
        var s = `<div class='exts'>`;
        Object.keys(_exts).forEach(ext => s += ext[0] == '-' ?
            `<div><b></b><strong>${_exts[ext].name}</strong><div>` :
            `<div><b>${ext}</b>${_exts[ext].name}<div>`
        );
        s += `</div>`;
        _h('#tabs',s);
    }
}

function render_file(f)
{
    var txt = _exts[f.ext] ? _exts[f.ext].is_txt : false;
    var img = _exts[f.ext] ? _exts[f.ext].is_img : false;
    img = img || f.ext == 'fnt';
    var pre = !txt && !img;
    var controls = `<div class='radio'>`;
    var buttons = '';

    if (txt) {
        controls += `
            ${f.ext == 'bas' ? check_init('indent','Indent') : ""}
            ${f.ext == 'fnt' ? check_init('multicolor','Multicolor') : ""}
            ${radio_init('layout',['38','40','80','Wide'])}`;
        buttons += `<button onclick="save(1)">Save As LST</button>`;
    }
    if ((f.ext == 'fnt') || (img && is_palettable(f.ext)))
        controls += `<div class="palette" style="display:inline-block">${palette(_palette)}</div>`;

    buttons += `<button onclick="save(0)">Download</button>`;
    controls += `</div>`;

    _h("#tabs",
        `<div class='info'>
            <div style='overflow: auto'>
                <b>${f.name}</b><div style='display:inline-block;float:right'>${buttons}</div>
            </div>
            <div style="font-size:small">
                ${ext_option(f)} ${f.data.length} bytes
                <div style='display:inline-block;float:right'>${controls}</div>
            </div>
        </div>
        <div id="file">
            <div>
                ${pre ? `<pre id='show'></pre>` : ''}
                ${img ? `<canvas id='show'></canvas>` : ''}
                ${txt ? `<div contenteditable='true' spellcheck='false' class='atari' id='atari_text'></div>` : ''}
            </div>
            <div id="image_controls"></div>
        </div>`
    );
    if (f.edit_img)
        refresh_image_controls(f);
}

var _keyboard;
function render_kb(vis)
{
    var kb = _q(".keyboard");
    if (!_keyboard) {
        var s = `<div>`;
        for (var y = 0; y < 16; y++) {
            s += '<div>';
            for (var x = 0; x < 16; x++)
                s += '<span>'+String.fromCharCode(x + y*16 + 0xE000)+'</span>';
            s += '</div>';
        }
        kb.innerHTML = s;
        kb.onclick = e => keyboard(e.target.innerText);
        _keyboard = kb;
    }

    //vis = vis && _q("#atari_text");
    kb.style.display = vis ? "block" : "none";
    keyboard();
}

function toggle_kb()
{
    render_kb(_q(".keyboard").style.display != "block");
}

function set_tool(name,v)
{
    set_class(_q("#"+name),"dimmed",!v);
}

function floater(evt)
{
    var t = evt.target.innerText;
    if (t == String.fromCharCode(0xE000))
        toggle_kb();
    else if (t == "I")
        invert_selection();
    else if (t == "D")
        disassemble_selection();
    else if (t == "O")
        open();
    else if (t == "H")
        toggle_hex();
}

function draggable(el,name)
{
    var x0,y0;
    el.querySelector('.draggable').innerText = name;
    el.onmousedown = (e) => {
        e.preventDefault();
        x0 = e.clientX;
        y0 = e.clientY;
        document.onmouseup = () => {
            document.onmouseup = null;
            document.onmousemove = null;
        }
        document.onmousemove = (e) => {
            e.preventDefault();
            var x = x0 - e.clientX;
            var y = y0 - e.clientY;
            x0 = e.clientX;
            y0 = e.clientY;
            el.style.left = (el.offsetLeft - x) + "px";
            el.style.top = (el.offsetTop - y) + "px";
        }
    }
}

</script>
<body>
<div class="floater atari keyboard"></div>
<div class="floater disassembly" hidden>
    <span class='close-icon' onclick='this.parentElement.hidden = true'></span>
    <div class='draggable'>
    </div>
    <pre id='disassembly'></pre>
</div>
<div class="floater atari tools" onclick='floater(event)' id="tools">
    <span title='ATASCII Keyboard'>&#xE000</span><br/>
    <span title='Open File'>O</span><br/>
    <span title='Toggle Hex View'>H</span><br/>
    <span id="I" class='dimmed' title='Invert Selection'>I</span><br/>
    <span id="D" class='dimmed' title='Disassemble Selection'>D</span><br/>
</div>
<header>
<h2>ATR Image Explorer</h2>
<br />
</header>
<div style="display:flex;flex-direction:row">

<nav style="min-width:352px; max-width:352px; margin-right:8px;" id="toc">
<div id="menu_container" ></div>
<p style="text-align:center;color:#AAA;font-weight:300">
    <span class='open' onclick='_q("#fe").click()'>Open</span><br/>
    <a href="https://github.com/rossumur/esp_8_bit">https://github.com/rossumur/esp_8_bit</a><br/><br/>
    <i><b>Ctrl+O</b> opens File Dialog</i><br/>
    <i><b>Ctrl+H</b> toggles Hex View</i><br/>
    <i><b>Shift+Click</b> opens Keyboard in Editor</i><br/>
</p>
<input type="file" id="fe" multiple style="display:none">
</nav>

<main style="border:solid 1px #CCC">
    <div id="tabs"></div>
</main>
</div>
<script>load()</script>
</body>
</html>
